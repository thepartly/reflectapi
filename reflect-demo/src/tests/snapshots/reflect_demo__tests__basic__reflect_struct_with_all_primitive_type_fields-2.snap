---
source: reflect-demo/src/tests/basic.rs
expression: "super::into_typescript_code::<TestStructWithAllPrimitiveTypeFields>()"
---
// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflect-cli
//
// Schema name: 
// 

export function client(base: string | Client): __definition.Interface {
    return __implementation.__client(base)
}

export namespace __definition {

export interface Interface {
    : (input: reflect_demo.tests.basic.TestStructWithAllPrimitiveTypeFields, headers: {})
        => AsyncResult<reflect_demo.tests.basic.TestStructWithAllPrimitiveTypeFields, {}>,
}

}

export interface Client {
    request(path: string, body: string, headers: Record<string, string>): Promise<[number, string]>;
}

export type AsyncResult<T, E> = Promise<Result<T, Err<E>>>;

export class Result<T, E> {
    constructor(private value: { ok: T } | { err: E }) {}

    public ok(): T | undefined {
        if ('ok' in this.value) {
            return this.value.ok;
        }
    }
    public err(): E | undefined {
        if ('err' in this.value) {
            return this.value.err;
        }
    }

    public is_ok(): boolean {
        return 'ok' in this.value;
    }
    public is_err(): boolean {
        return 'err' in this.value;
    }

    public map<U>(f: (r: T) => U): Result<U, E> {
        if ('ok' in this.value) {
            return new Result({ ok: f(this.value.ok) });
        } else {
            return new Result({ err: this.value.err });
        }
    }
    public map_err<U>(f: (r: E) => U): Result<T, U> {
        if ('err' in this.value) {
            return new Result({ err: f(this.value.err) });
        } else {
            return new Result({ ok: this.value.ok });
        }
    }

    public unwrap_ok(): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        throw new Error('called `unwrap_ok` on an `err` value: ' + this.value.toString());
    }
    public unwrap_err(): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        throw new Error('called `unwrap_err` on an `ok` value');
    }

    public unwrap_ok_or_default(default_: T): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        return default_;
    }
    public unwrap_err_or_default(default_: E): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        return default_;
    }

    public unwrap_ok_or_else(f: () => T): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        return f();
    }
    public unwrap_err_or_else(f: () => E): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        return f();
    }

    public toString(): string {
        if ('ok' in this.value) {
            return `Ok { ok: ${this.value.ok} }`;
        } else {
            return `Err { err: ${this.value.err} }`;
        }
    }
}

export class Err<E> {
    constructor(private value: { server_err: E } | { network_err: any }) { }

    public err(): E | undefined {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
    }
    public network_err(): any | undefined {
        if ('network_err' in this.value) {
            return this.value.network_err;
        }
    }

    public is_err(): boolean {
        return 'server_err' in this.value;
    }
    public is_network_err(): boolean {
        return 'network_err' in this.value;
    }

    public map<U>(f: (r: E) => U): Err<U> {
        if ('server_err' in this.value) {
            return new Err({ server_err: f(this.value.server_err) });
        } else {
            return new Err({ network_err: this.value.network_err });
        }
    }
    public unwrap(): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        } else {
            throw this.value;
        }
    }
    public unwrap_or_default(default_: E): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
        return default_;
    }
    public unwrap_or_else(f: () => E): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
        return f();
    }

    public toString(): string {
        if ('server_err' in this.value) {
            return `Err { server_err: ${this.value.server_err} }`;
        } else {
            return `Err { network_err: ${this.value.network_err} }`;
        }
    }
}

export namespace reflect {

/// Struct object with no fields
export interface Empty {
}

/// Error object which is expected to be never returned
export interface Infallible {
}

}

export namespace reflect_demo {

export namespace tests {

export namespace basic {

export interface TestStructWithAllPrimitiveTypeFields {
    _f_u8: number /* u8 */,
    _f_u16: number /* u16 */,
    _f_u32: number /* u32 */,
    _f_u64: number /* u64 */,
    _f_u128: number /* u128 */,
    _f_usize: number /* u64 */,
    _f_i8: number /* i8 */,
    _f_i16: number /* i16 */,
    _f_i32: number /* i32 */,
    _f_i64: number /* i64 */,
    _f_i128: number /* i128 */,
    _f_isize: number /* i64 */,
    _f_f32: number /* f32 */,
    _f_f64: number /* f64 */,
    _f_bool: boolean,
    _f_char: string,
    _f_str: string,
    _f_unit: null,
    _f_option: number /* u8 */ | null,
    _f_vec: Array<number /* u8 */>,
    _f_hashmap: Record<number /* u8 */, string>,
    _f_hashset: Array<number /* u8 */>,
    _f_tuple: [number /* u8 */, string],
    _f_tuple3: [number /* u8 */, string, number /* u8 */],
    _f_tuple4: [number /* u8 */, string, number /* u8 */, string],
    _f_tuple5: [number /* u8 */, string, number /* u8 */, string, number /* u8 */],
    _f_tuple6: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string],
    _f_tuple7: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */],
    _f_tuple8: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, string],
    _f_tuple9: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */],
    _f_tuple10: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, number /* u8 */0],
    _f_tuple11: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, number /* u8 */0, number /* u8 */1],
    _f_tuple12: [number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, string, number /* u8 */, number /* u8 */0, number /* u8 */1, number /* u8 */2],
    _f_array: Array<number /* u8 */>,
    _f_pointer_box: number /* u8 */,
    _f_pointer_arc: number /* u8 */,
    _f_pointer_cell: number /* u8 */,
    _f_pointer_refcell: number /* u8 */,
    _f_pointer_mutex: number /* u8 */,
    _f_pointer_rwlock: number /* u8 */,
    _f_pointer_weak: number /* u8 */,
    _f_phantomdata: undefined | number /* u8 */ /* phantom data */,
    _f_infallible: reflect.Infallible,
}

}

}

}

namespace __implementation {

export function __client(base: string | Client): __definition.Interface {
    const client_instance = typeof base === 'string' ? new ClientInstance(base) : base;
    return { impl: {
        : (client_instance),
    }, }.impl
}

export async function __request<I, H, O, E>(client: Client, path: string, input: I | undefined, headers: H | undefined): AsyncResult<O, E> {
    let hdrs: Record<string, string> = {
        'content-type': 'application/json',
    };
    if (headers) {
        let hdrs: Record<string, string> = {};
        for (const [k, v] of Object.entries(headers)) {
            hdrs[k?.toString()] = v?.toString() || '';
        }
    }
    try {
        let [status, response_body] = await client.request(path, JSON.stringify(input), hdrs);
        if (status < 200 || status >= 300) {
            return new Result({ err: new Err({ server_err: JSON.parse(response_body) as E }) });
        }
        return new Result({ ok: JSON.parse(response_body) as O });
    } catch (e) {
        return new Result({ err: new Err({ network_err: e }) });
    }
}

class ClientInstance {
    constructor(private base: string) {}

    public request(path: string, body: string, headers: Record<string, string>): Promise<[number, string]> {
        return fetch(`${this.base}/${path}`, {
            method: 'POST',
            headers: headers,
            body: body,
        }).then(async (response) => {
            return [response.status, await response.text()];
        });
    }
}

function (client: Client) {
    return (input: reflect_demo.tests.basic.TestStructWithAllPrimitiveTypeFields, headers: {}) => __request<
        reflect_demo.tests.basic.TestStructWithAllPrimitiveTypeFields, {}, reflect_demo.tests.basic.TestStructWithAllPrimitiveTypeFields, {}
    >(client, '', input, headers);
}

}
