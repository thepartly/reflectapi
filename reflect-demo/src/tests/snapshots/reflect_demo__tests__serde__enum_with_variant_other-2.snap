---
source: reflect-demo/src/tests/serde.rs
expression: "super::into_typescript_code::<TestEnumWithVariantOther>()"
---
// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflect-cli
//
// Schema name: 
// 

export function client(base: string | Client): __definition.Interface {
    return __implementation.__client(base)
}

export namespace __definition {

export interface Interface {
    : (input: reflect_demo.tests.serde.input.TestEnumWithVariantOther, headers: {})
        => AsyncResult<reflect_demo.tests.serde.output.TestEnumWithVariantOther, {}>,
}

}

export interface Client {
    request(path: string, body: string, headers: Record<string, string>): Promise<[number, string]>;
}

export type AsyncResult<T, E> = Promise<Result<T, Err<E>>>;

export class Result<T, E> {
    constructor(private value: { ok: T } | { err: E }) {}

    public ok(): T | undefined {
        if ('ok' in this.value) {
            return this.value.ok;
        }
    }
    public err(): E | undefined {
        if ('err' in this.value) {
            return this.value.err;
        }
    }

    public is_ok(): boolean {
        return 'ok' in this.value;
    }
    public is_err(): boolean {
        return 'err' in this.value;
    }

    public map<U>(f: (r: T) => U): Result<U, E> {
        if ('ok' in this.value) {
            return new Result({ ok: f(this.value.ok) });
        } else {
            return new Result({ err: this.value.err });
        }
    }
    public map_err<U>(f: (r: E) => U): Result<T, U> {
        if ('err' in this.value) {
            return new Result({ err: f(this.value.err) });
        } else {
            return new Result({ ok: this.value.ok });
        }
    }

    public unwrap_ok(): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        throw new Error('called `unwrap_ok` on an `err` value: ' + this.value.toString());
    }
    public unwrap_err(): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        throw new Error('called `unwrap_err` on an `ok` value');
    }

    public unwrap_ok_or_default(default_: T): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        return default_;
    }
    public unwrap_err_or_default(default_: E): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        return default_;
    }

    public unwrap_ok_or_else(f: () => T): T {
        if ('ok' in this.value) {
            return this.value.ok;
        }
        return f();
    }
    public unwrap_err_or_else(f: () => E): E {
        if ('err' in this.value) {
            return this.value.err;
        }
        return f();
    }

    public toString(): string {
        if ('ok' in this.value) {
            return `Ok { ok: ${this.value.ok} }`;
        } else {
            return `Err { err: ${this.value.err} }`;
        }
    }
}

export class Err<E> {
    constructor(private value: { server_err: E } | { network_err: any }) { }

    public err(): E | undefined {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
    }
    public network_err(): any | undefined {
        if ('network_err' in this.value) {
            return this.value.network_err;
        }
    }

    public is_err(): boolean {
        return 'server_err' in this.value;
    }
    public is_network_err(): boolean {
        return 'network_err' in this.value;
    }

    public map<U>(f: (r: E) => U): Err<U> {
        if ('server_err' in this.value) {
            return new Err({ server_err: f(this.value.server_err) });
        } else {
            return new Err({ network_err: this.value.network_err });
        }
    }
    public unwrap(): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        } else {
            throw this.value;
        }
    }
    public unwrap_or_default(default_: E): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
        return default_;
    }
    public unwrap_or_else(f: () => E): E {
        if ('server_err' in this.value) {
            return this.value.server_err;
        }
        return f();
    }

    public toString(): string {
        if ('server_err' in this.value) {
            return `Err { server_err: ${this.value.server_err} }`;
        } else {
            return `Err { network_err: ${this.value.network_err} }`;
        }
    }
}

export namespace reflect {

/// Struct object with no fields
export interface Empty {
}

/// Error object which is expected to be never returned
export interface Infallible {
}

}

export namespace reflect_demo {

export namespace tests {

export namespace serde {

export namespace input {

export type TestEnumWithVariantOther =
    | "V0";

}

export namespace output {

export type TestEnumWithVariantOther =
    | "V0"
    | "Variant1";

}

}

}

}

namespace __implementation {

export function __client(base: string | Client): __definition.Interface {
    const client_instance = typeof base === 'string' ? new ClientInstance(base) : base;
    return { impl: {
        : (client_instance),
    }, }.impl
}

export async function __request<I, H, O, E>(client: Client, path: string, input: I | undefined, headers: H | undefined): AsyncResult<O, E> {
    let hdrs: Record<string, string> = {
        'content-type': 'application/json',
    };
    if (headers) {
        let hdrs: Record<string, string> = {};
        for (const [k, v] of Object.entries(headers)) {
            hdrs[k?.toString()] = v?.toString() || '';
        }
    }
    try {
        let [status, response_body] = await client.request(path, JSON.stringify(input), hdrs);
        if (status < 200 || status >= 300) {
            return new Result({ err: new Err({ server_err: JSON.parse(response_body) as E }) });
        }
        return new Result({ ok: JSON.parse(response_body) as O });
    } catch (e) {
        return new Result({ err: new Err({ network_err: e }) });
    }
}

class ClientInstance {
    constructor(private base: string) {}

    public request(path: string, body: string, headers: Record<string, string>): Promise<[number, string]> {
        return fetch(`${this.base}/${path}`, {
            method: 'POST',
            headers: headers,
            body: body,
        }).then(async (response) => {
            return [response.status, await response.text()];
        });
    }
}

function (client: Client) {
    return (input: reflect_demo.tests.serde.input.TestEnumWithVariantOther, headers: {}) => __request<
        reflect_demo.tests.serde.input.TestEnumWithVariantOther, {}, reflect_demo.tests.serde.output.TestEnumWithVariantOther, {}
    >(client, '', input, headers);
}

}
