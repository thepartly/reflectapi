# Integrating with Axum

Learn how to integrate `reflectapi` with the Axum web framework to build production-ready HTTP APIs with comprehensive middleware support.

## Overview

`reflectapi` provides first-class integration with Axum through the `reflectapi::axum` module. The generated routers seamlessly integrate with Axum's type-safe routing system, allowing you to leverage Axum's full ecosystem of middleware.

**Handler Signature**: `reflectapi` handlers have a fixed signature of `async fn(State, Input, Headers) -> Result<Output, Error>`. Middleware data must be passed through the State parameter.

## Basic Integration

Here's a complete example of setting up an Axum server with `reflectapi`:

```rust,ignore
use std::error::Error;
use axum::{response::Html, Json, Router};
use reflectapi::{Builder, Input, Output};

// Define your API types
#[derive(serde::Serialize, serde::Deserialize, Input, Output)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// Define your handler
async fn get_user(
    _state: (),
    id: u32,
    _headers: (),
) -> Result<User, String> {
    Ok(User {
        id,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Build the API schema and routers
    let builder = Builder::new()
        .name("My API")
        .route(reflectapi::routing::get::<u32, (), User, String>(
            "/users/:id",
            get_user,
        ));
    
    let (schema, routers) = builder.build()?;
    
    // Convert to Axum router
    let app_state = ();  // Your application state
    let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
        // Apply middleware to each router
        r.layer(tower_http::trace::TraceLayer::new_for_http())
    });
    
    // Start the server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Server running on http://0.0.0.0:3000");
    axum::serve(listener, axum_app).await?;
    
    Ok(())
}
```

## Adding Application State

Most real applications need shared state. Here's how to integrate with Axum's state management:

```rust,ignore
use std::sync::Arc;
use sqlx::PgPool;

#[derive(Clone)]
struct AppState {
    db: PgPool,
    config: Arc<Config>,
}

// Update your handlers to receive state
async fn get_user(
    state: AppState,
    id: u32,
    _headers: (),
) -> Result<User, ApiError> {
    let user = sqlx::query_as!(
        User,
        "SELECT id, name, email FROM users WHERE id = $1",
        id as i32
    )
    .fetch_one(&state.db)
    .await
    .map_err(|_| ApiError::NotFound)?;
    
    Ok(user)
}

// Pass state when building the router
let app_state = AppState {
    db: pool.clone(),
    config: Arc::new(config),
};

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| r);
```

## Middleware Integration

`reflectapi` integrates seamlessly with Axum's Tower middleware ecosystem. Middleware can be applied at different levels and middleware data is passed to handlers through the state parameter.

### Understanding the into_router Closure

The `into_router` function takes a closure `|name, router| router` where:
- `name` corresponds to the name provided to `Builder::new().name("My API")`
- This is useful when merging multiple builders or applying conditional middleware
- The closure returns the modified router with middleware applied

### Global Middleware

Apply middleware to all generated routes:

```rust,ignore
use tower_http::{
    compression::CompressionLayer,
    cors::CorsLayer,
    trace::TraceLayer,
};
use tower::ServiceBuilder;

let middleware_stack = ServiceBuilder::new()
    .layer(TraceLayer::new_for_http())
    .layer(CompressionLayer::new())
    .layer(CorsLayer::permissive());

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(middleware_stack)
});
```

### Per-Router Middleware

Apply different middleware based on the router name:

```rust,ignore
let axum_app = reflectapi::axum::into_router(app_state, routers, |name, r| {
    match name {
        "public" => r.layer(CorsLayer::permissive()),
        "admin" => r.layer(middleware::from_fn(admin_auth_middleware)),
        "internal" => r.layer(middleware::from_fn(internal_only_middleware)),
        _ => r,
    }
});
```

### Applying Middleware to Generated Routes

Apply middleware to all routes generated by `reflectapi`:

```rust,ignore
use axum::middleware;

// This applies to ALL generated routes
let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| r)
    .route_layer(middleware::from_fn(auth_middleware));
```

## Authentication Middleware

Implement authentication that works with `reflectapi` handlers:

```rust,ignore
use axum::{
    http::{Request, StatusCode},
    middleware::{self, Next},
    response::Response,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Clone, Debug)]
pub struct AuthUser {
    pub id: u32,
    pub email: String,
    pub roles: Vec<String>,
}

#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
    // Store authenticated user in request-scoped state
    pub current_user: Arc<RwLock<Option<AuthUser>>>,
}

pub async fn auth_middleware<B>(
    mut req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    // Extract token from Authorization header
    let token = req
        .headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .and_then(|h| h.strip_prefix("Bearer "))
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // Validate JWT token
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(b"secret"),
        &Validation::default(),
    )
    .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    // Create user from claims
    let user = AuthUser {
        id: token_data.claims.sub,
        email: token_data.claims.email,
        roles: token_data.claims.roles,
    };
    
    // Store user in request-local state
    req.extensions_mut().insert(user);
    
    Ok(next.run(req).await)
}

// Apply authentication middleware
let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(middleware::from_fn(auth_middleware))
});
```

### Accessing Authentication Data in Handlers

Pass authentication data to `reflectapi` handlers through state:

```rust,ignore
use axum::Extension;

// Extend your state to include user information
#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
    pub config: Arc<Config>,
}

// Custom headers type that can extract user from extensions
#[derive(serde::Deserialize, reflectapi::Input)]
pub struct AuthHeaders {
    #[serde(skip)]  // Not from HTTP headers
    pub user: Option<AuthUser>,
}

impl AuthHeaders {
    pub fn from_request(req: &axum::http::Request<axum::body::Body>) -> Self {
        let user = req.extensions().get::<AuthUser>().cloned();
        Self { user }
    }
}

// Use in your handlers
async fn get_current_user(
    state: AppState,
    _input: (),
    headers: AuthHeaders,
) -> Result<UserProfile, ApiError> {
    let user = headers.user.ok_or(ApiError::Unauthorized)?;
    
    // Use the authenticated user
    let profile = fetch_user_profile(&state.db, user.id).await?;
    Ok(profile)
}

async fn create_post(
    state: AppState,
    request: CreatePostRequest,
    headers: AuthHeaders,
) -> Result<Post, ApiError> {
    let user = headers.user.ok_or(ApiError::Unauthorized)?;
    
    // Verify user has permission to create posts
    if !user.roles.contains(&"author".to_string()) {
        return Err(ApiError::Forbidden);
    }
    
    // Create post with user as author
    let post = create_post_in_db(&state.db, request, user.id).await?;
    Ok(post)
}
```

## CORS Configuration

Enable Cross-Origin Resource Sharing for browser-based clients:

```rust,ignore
use tower_http::cors::{CorsLayer, Any};
use http::{Method, HeaderName};
use std::time::Duration;

let cors_layer = CorsLayer::new()
    // Allow specific origins
    .allow_origin([
        "http://localhost:3000".parse().unwrap(),
        "https://app.example.com".parse().unwrap(),
    ])
    // Or allow any origin (use with caution in production)
    // .allow_origin(Any)
    
    // Allow specific methods
    .allow_methods([
        Method::GET,
        Method::POST,
        Method::PUT,
        Method::DELETE,
        Method::OPTIONS,
    ])
    
    // Allow specific headers
    .allow_headers([
        HeaderName::from_static("content-type"),
        HeaderName::from_static("authorization"),
        HeaderName::from_static("x-request-id"),
    ])
    
    // Expose headers to the browser
    .expose_headers([
        HeaderName::from_static("x-request-id"),
        HeaderName::from_static("x-total-count"),
    ])
    
    // Allow credentials
    .allow_credentials(true)
    
    // Cache preflight for 1 hour
    .max_age(Duration::from_secs(3600));

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(cors_layer)
});
```

## Request Tracing and Logging

Log all incoming requests with detailed information:

```rust,ignore
use tower_http::trace::{self, TraceLayer};
use tracing::{info, error, Span};
use std::time::Duration;

let trace_layer = TraceLayer::new_for_http()
    .make_span_with(|request: &Request<_>| {
        let matched_path = request
            .extensions()
            .get::<axum::extract::MatchedPath>()
            .map(|p| p.as_str());
        
        tracing::info_span!(
            "http_request",
            method = ?request.method(),
            matched_path,
            uri = %request.uri(),
        )
    })
    .on_request(|request: &Request<_>, _span: &Span| {
        info!("Started processing request");
    })
    .on_response(|response: &Response, latency: Duration, _span: &Span| {
        info!(
            status = response.status().as_u16(),
            latency = ?latency,
            "Finished processing request"
        );
    })
    .on_failure(|error: tower_http::classify::ServerErrorsFailureClass, _latency: Duration, _span: &Span| {
        error!("Request failed: {:?}", error);
    });

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(trace_layer)
});
```

## Rate Limiting

Protect your API from abuse with rate limiting:

```rust,ignore
use tower_governor::{governor::GovernorConfigBuilder, GovernorLayer};
use std::sync::Arc;

// Configure rate limiter
let governor_conf = Arc::new(
    GovernorConfigBuilder::default()
        .per_second(10)  // 10 requests per second
        .burst_size(100) // Allow bursts up to 100
        .finish()
        .unwrap(),
);

let governor_layer = GovernorLayer {
    config: governor_conf,
};

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(governor_layer)
});
```

## Request ID Tracking

Add unique request IDs for tracing and debugging:

```rust,ignore
use uuid::Uuid;
use axum::http::HeaderValue;

pub async fn request_id_middleware<B>(
    mut req: Request<B>,
    next: Next<B>,
) -> Response {
    // Get or generate request ID
    let request_id = req
        .headers()
        .get("x-request-id")
        .and_then(|h| h.to_str().ok())
        .map(String::from)
        .unwrap_or_else(|| Uuid::new_v4().to_string());
    
    // Add to extensions for logging
    req.extensions_mut().insert(request_id.clone());
    
    // Process request
    let mut response = next.run(req).await;
    
    // Add request ID to response headers
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&request_id).unwrap(),
    );
    
    response
}

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(middleware::from_fn(request_id_middleware))
});
```

## Compression and Performance

Automatically compress responses for better performance:

```rust,ignore
use tower_http::compression::CompressionLayer;
use tower_http::compression::predicate::{SizeAbove, Predicate};
use tower::timeout::TimeoutLayer;
use std::time::Duration;

// Compression
let compression_layer = CompressionLayer::new()
    // Only compress responses larger than 1KB
    .compress_when(SizeAbove::new(1024));

// Timeout protection
let timeout_layer = TimeoutLayer::new(Duration::from_secs(30));

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(compression_layer)
     .layer(timeout_layer)
});
```

## Error Recovery

Handle panics gracefully without crashing the server:

```rust,ignore
use tower_http::catch_panic::CatchPanicLayer;
use axum::response::Response;
use axum::body::Body;

let catch_panic_layer = CatchPanicLayer::custom(|_err| {
    Response::builder()
        .status(StatusCode::INTERNAL_SERVER_ERROR)
        .body(Body::from("Internal server error"))
        .unwrap()
});

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(catch_panic_layer)
});
```

## Layering Multiple Middleware

Apply middleware in the correct order for proper functionality:

```rust,ignore
use tower::ServiceBuilder;

let middleware_stack = ServiceBuilder::new()
    // Outermost: catch panics first
    .layer(CatchPanicLayer::new())
    // Add request ID early
    .layer(middleware::from_fn(request_id_middleware))
    // Logging should see all requests
    .layer(TraceLayer::new_for_http())
    // CORS before authentication
    .layer(cors_layer)
    // Rate limiting
    .layer(governor_layer)
    // Authentication
    .layer(middleware::from_fn(auth_middleware))
    // Compression last (closest to handler)
    .layer(compression_layer);

let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
    r.layer(middleware_stack)
});
```

## Conditional Middleware

Apply middleware conditionally based on router name:

```rust,ignore
let axum_app = reflectapi::axum::into_router(app_state, routers, |name, r| {
    match name {
        "public" => {
            // Public API: CORS + rate limiting only
            r.layer(cors_layer.clone())
             .layer(rate_limit_layer.clone())
        }
        "admin" => {
            // Admin API: authentication + audit logging
            r.layer(middleware::from_fn(admin_auth_middleware))
             .layer(middleware::from_fn(audit_log_middleware))
        }
        "internal" => {
            // Internal API: no public access
            r.layer(middleware::from_fn(internal_only_middleware))
        }
        _ => r,
    }
});
```

## Testing Middleware

Test your middleware in isolation:

```rust,ignore
#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use tower::ServiceExt;
    
    #[tokio::test]
    async fn test_auth_middleware() {
        let app = create_app_with_middleware();
        
        // Test without auth header
        let response = app
            .clone()
            .oneshot(
                Request::builder()
                    .uri("/protected")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        
        // Test with valid token
        let response = app
            .oneshot(
                Request::builder()
                    .uri("/protected")
                    .header("Authorization", "Bearer valid-token")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();
        
        assert_eq!(response.status(), StatusCode::OK);
    }
}

## Adding Additional Routes

You can extend the generated router with additional Axum routes:

```rust,ignore
// Generate `reflectapi` routes
let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| r)
    // Add OpenAPI spec endpoint
    .route(
        "/openapi.json",
        axum::routing::get(|| async { 
            Json(openapi_spec) 
        }),
    )
    // Add documentation UI
    .route(
        "/doc",
        axum::routing::get(|| async { 
            Html(include_str!("./swagger-ui.html")) 
        }),
    )
    // Add health check
    .route(
        "/health",
        axum::routing::get(|| async { 
            Json(serde_json::json!({ "status": "healthy" })) 
        }),
    )
    // Serve static files
    .nest_service(
        "/static",
        tower_http::services::ServeDir::new("static"),
    );
```

## Error Handling

Integrate `reflectapi` errors with Axum's error handling:

```rust,ignore
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};

#[derive(serde::Serialize, serde::Deserialize, Output)]
pub struct ApiError {
    pub code: String,
    pub message: String,
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let status = match self.code.as_str() {
            "NOT_FOUND" => StatusCode::NOT_FOUND,
            "UNAUTHORIZED" => StatusCode::UNAUTHORIZED,
            "VALIDATION_ERROR" => StatusCode::BAD_REQUEST,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };
        
        (status, Json(self)).into_response()
    }
}
```

## Complete Example

Here's a production-ready example from the demo application:

```rust,ignore
use axum::{response::Html, Json};
use tower_http::trace::TraceLayer;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Build the API
    let builder = reflectapi_demo::builder();
    let (schema, routers) = builder.build()?;
    
    // Generate OpenAPI spec
    let openapi_spec = reflectapi::codegen::openapi::Spec::from(&schema);
    
    // Save schema for client generation
    tokio::fs::write(
        "reflectapi.json",
        serde_json::to_string_pretty(&schema)?,
    ).await?;
    
    // Build Axum application
    let app_state = Default::default();
    let axum_app = reflectapi::axum::into_router(app_state, routers, |_name, r| {
        // Add tracing to all routes
        r.layer(TraceLayer::new_for_http())
    })
    // Add OpenAPI endpoint
    .route(
        "/openapi.json",
        axum::routing::get(move || async move { 
            Json(openapi_spec.clone()) 
        }),
    )
    // Add Swagger UI
    .route(
        "/doc",
        axum::routing::get(|| async { 
            Html(include_str!("./swagger-ui.html")) 
        }),
    )
    // Add ReDoc UI
    .route(
        "/redoc",
        axum::routing::get(|| async { 
            Html(include_str!("./redoc.html")) 
        }),
    );
    
    // Start server
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let bind_addr = format!("0.0.0.0:{}", port);
    let listener = tokio::net::TcpListener::bind(&bind_addr).await?;
    eprintln!("Listening on http://{}", bind_addr);
    
    axum::serve(listener, axum_app).await?;
    
    Ok(())
}
```

## Testing Your Axum Integration

Use Axum's built-in testing utilities:

```rust,ignore
#[cfg(test)]
mod tests {
    use axum::http::StatusCode;
    use axum_test::TestServer;
    
    #[tokio::test]
    async fn test_api_endpoint() {
        let app = create_app().await;
        let server = TestServer::new(app).unwrap();
        
        let response = server
            .get("/users/1")
            .await;
        
        assert_eq!(response.status_code(), StatusCode::OK);
        
        let user: User = response.json();
        assert_eq!(user.id, 1);
    }
}
```

## Best Practices

1. **Organize Routes**: Group related endpoints into separate builders/routers for better organization
2. **Use Type-Safe State**: Leverage Axum's type-safe state extraction instead of globals
3. **Layer Middleware Appropriately**: Apply middleware at the right level (global vs route-specific)
4. **Handle Errors Consistently**: Use a unified error type that implements `IntoResponse`
5. **Document Your API**: Serve OpenAPI spec and documentation UI endpoints
6. **Monitor Performance**: Use tracing middleware to monitor request/response times

## Middleware Best Practices

1. **Order Matters**: Apply middleware in the correct order (e.g., logging before auth)
2. **Performance First**: Put expensive middleware closer to handlers  
3. **Fail Fast**: Authentication/authorization should happen early
4. **Use State for Data**: Pass middleware data to handlers through the state parameter
5. **Error Handling**: Always provide meaningful error responses
6. **Monitor Impact**: Measure middleware performance impact
7. **Test Thoroughly**: Test middleware both in isolation and integration

## Next Steps

- Learn about [OpenAPI Integration](./openapi.md) to generate API documentation
- Explore [Working with Custom Types](./custom-types.md) for strong typing patterns
- See [Performance Optimization](./performance.md) for production tuning