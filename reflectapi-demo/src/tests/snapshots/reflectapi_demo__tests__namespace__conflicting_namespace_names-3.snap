---
source: reflectapi-demo/src/tests/namespace.rs
expression: rust
---
// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: foo
//

#![allow(non_camel_case_types)]
#![allow(dead_code)]

pub use interface::Interface;
pub use reflectapi::rt::*;

pub mod interface {

    #[derive(Debug)]
    pub struct Interface<C: reflectapi::rt::Client + Clone> {
        pub x: XInterface<C>,
        pub y: YInterface<C>,
        client: C,
        base_url: reflectapi::rt::Url,
    }

    impl<C: reflectapi::rt::Client + Clone> Interface<C> {
        pub fn try_new(
            client: C,
            base_url: reflectapi::rt::Url,
        ) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
            if base_url.cannot_be_a_base() {
                return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
            }

            Ok(Self {
                x: XInterface::try_new(client.clone(), base_url.clone())?,
                y: YInterface::try_new(client.clone(), base_url.clone())?,
                client,
                base_url,
            })
        }
    }

    #[derive(Debug)]
    pub struct XInterface<C: reflectapi::rt::Client + Clone> {
        pub foo: XFooInterface<C>,
        client: C,
        base_url: reflectapi::rt::Url,
    }

    impl<C: reflectapi::rt::Client + Clone> XInterface<C> {
        pub fn try_new(
            client: C,
            base_url: reflectapi::rt::Url,
        ) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
            if base_url.cannot_be_a_base() {
                return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
            }

            Ok(Self {
                foo: XFooInterface::try_new(client.clone(), base_url.clone())?,
                client,
                base_url,
            })
        }
    }

    #[derive(Debug)]
    pub struct XFooInterface<C: reflectapi::rt::Client + Clone> {
        client: C,
        base_url: reflectapi::rt::Url,
    }

    impl<C: reflectapi::rt::Client + Clone> XFooInterface<C> {
        pub fn try_new(
            client: C,
            base_url: reflectapi::rt::Url,
        ) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
            if base_url.cannot_be_a_base() {
                return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
            }

            Ok(Self { client, base_url })
        }
        pub async fn get(
            &self,
            input: reflectapi::Empty,
            headers: reflectapi::Empty,
        ) -> Result<
            reflectapi::rt::ApiResult<reflectapi::Empty>,
            reflectapi::rt::Error<reflectapi::Empty, C::Error>,
        > {
            reflectapi::rt::__request_impl(
                &self.client,
                self.base_url
                    .join("/x.foo.get")
                    .expect("checked base_url already and path is valid"),
                input,
                headers,
            )
            .await
        }
    }

    #[derive(Debug)]
    pub struct YInterface<C: reflectapi::rt::Client + Clone> {
        pub foo: YFooInterface<C>,
        client: C,
        base_url: reflectapi::rt::Url,
    }

    impl<C: reflectapi::rt::Client + Clone> YInterface<C> {
        pub fn try_new(
            client: C,
            base_url: reflectapi::rt::Url,
        ) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
            if base_url.cannot_be_a_base() {
                return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
            }

            Ok(Self {
                foo: YFooInterface::try_new(client.clone(), base_url.clone())?,
                client,
                base_url,
            })
        }
    }

    #[derive(Debug)]
    pub struct YFooInterface<C: reflectapi::rt::Client + Clone> {
        client: C,
        base_url: reflectapi::rt::Url,
    }

    impl<C: reflectapi::rt::Client + Clone> YFooInterface<C> {
        pub fn try_new(
            client: C,
            base_url: reflectapi::rt::Url,
        ) -> std::result::Result<Self, reflectapi::rt::UrlParseError> {
            if base_url.cannot_be_a_base() {
                return Err(reflectapi::rt::UrlParseError::RelativeUrlWithCannotBeABaseBase);
            }

            Ok(Self { client, base_url })
        }
        pub async fn get(
            &self,
            input: reflectapi::Empty,
            headers: reflectapi::Empty,
        ) -> Result<reflectapi::rt::ApiResult<()>, reflectapi::rt::Error<reflectapi::Empty, C::Error>>
        {
            reflectapi::rt::__request_impl(
                &self.client,
                self.base_url
                    .join("/y.foo.get")
                    .expect("checked base_url already and path is valid"),
                input,
                headers,
            )
            .await
        }
    }
}
