---
source: reflectapi-demo/src/tests/basic.rs
expression: "super::into_rust_code::<TestStructWithAllPrimitiveTypeFields>()"
---
// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name:
//

#![allow(non_camel_case_types)]
#![allow(dead_code)]

pub use interface::Interface;

pub mod interface {

    #[derive(Debug)]
    pub struct Interface<C: super::Client + Clone> {
        client: C,
        base_url: std::string::String,
    }

    impl<C: super::Client + Clone> Interface<C> {
        pub fn new(client: C, base_url: std::string::String) -> Self {
            Self { client, base_url }
        }
        pub async fn inout_test(
            &self,
            input: super::types::reflectapi_demo::tests::basic::TestStructWithAllPrimitiveTypeFields,
            headers: reflectapi::Empty,
        ) -> Result<
            super::types::reflectapi_demo::tests::basic::TestStructWithAllPrimitiveTypeFields,
            super::Error<reflectapi::Empty, C::Error>,
        > {
            super::__request_impl(&self.client, &self.base_url, "/inout_test", input, headers).await
        }
    }
}

pub trait Client {
    type Error;

    fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> impl std::future::Future<Output = Result<(http::StatusCode, bytes::Bytes), Self::Error>>;
}

pub enum Error<AE, NE> {
    Application(AE),
    Network(NE),
    Protocol {
        info: String,
        stage: ProtocolErrorStage,
    },
    Server(http::StatusCode, bytes::Bytes),
}

pub enum ProtocolErrorStage {
    SerializeRequestBody,
    SerializeRequestHeaders,
    DeserializeResponseBody(bytes::Bytes),
    DeserializeResponseError(http::StatusCode, bytes::Bytes),
}

#[cfg(feature = "reqwest")]
impl Client for reqwest::Client {
    type Error = reqwest::Error;

    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), Self::Error> {
        let mut request = self.post(path);
        for (k, v) in headers {
            request = request.header(k, v);
        }
        let response = request.body(body).send().await;
        let response = match response {
            Ok(response) => response,
            Err(e) => return Err(e),
        };
        let status = response.status();
        let body = response.bytes().await;
        let body = match body {
            Ok(body) => body,
            Err(e) => return Err(e),
        };
        Ok((status, body))
    }
}

pub mod types {

    pub mod reflectapi_demo {
        pub mod tests {
            pub mod basic {

                #[derive(Debug, serde::Serialize, serde::Deserialize)]
                pub struct TestStructWithAllPrimitiveTypeFields {
                    pub _f_u8: u8,
                    pub _f_u16: u16,
                    pub _f_u32: u32,
                    pub _f_u64: u64,
                    pub _f_u128: u128,
                    pub _f_usize: usize,
                    pub _f_i8: i8,
                    pub _f_i16: i16,
                    pub _f_i32: i32,
                    pub _f_i64: i64,
                    pub _f_i128: i128,
                    pub _f_isize: isize,
                    pub _f_f32: f32,
                    pub _f_f64: f64,
                    pub _f_bool: bool,
                    pub _f_char: char,
                    pub _f_str: std::string::String,
                    pub _f_unit: (),
                    pub _f_option: std::option::Option<u8>,
                    pub _f_vec: std::vec::Vec<u8>,
                    pub _f_hashmap: std::collections::HashMap<u8, std::string::String>,
                    pub _f_hashset: std::collections::HashSet<u8>,
                    pub _f_tuple: (u8, std::string::String),
                    pub _f_tuple3: (u8, std::string::String, u8),
                    pub _f_tuple4: (u8, std::string::String, u8, std::string::String),
                    pub _f_tuple5: (u8, std::string::String, u8, std::string::String, u8),
                    pub _f_tuple6: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                    ),
                    pub _f_tuple7: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                    ),
                    pub _f_tuple8: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                    ),
                    pub _f_tuple9: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                    ),
                    pub _f_tuple10: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                    ),
                    pub _f_tuple11: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                    ),
                    pub _f_tuple12: (
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                        u8,
                        std::string::String,
                    ),
                    pub _f_array: [u8; 3],
                    pub _f_pointer_box: std::boxed::Box<u8>,
                    pub _f_pointer_arc: std::sync::Arc<u8>,
                    pub _f_pointer_cell: std::cell::Cell<u8>,
                    pub _f_pointer_refcell: std::cell::RefCell<u8>,
                    pub _f_pointer_mutex: std::sync::Mutex<u8>,
                    pub _f_pointer_rwlock: std::sync::RwLock<u8>,
                    pub _f_pointer_weak: std::sync::Weak<u8>,
                    pub _f_phantomdata: std::marker::PhantomData<u8>,
                    pub _f_infallible: reflectapi::Infallible,
                }
            }
        }
    }
}

async fn __request_impl<C, I, H, O, E>(
    client: &C,
    base_url: &str,
    path: &str,
    body: I,
    headers: H,
) -> Result<O, Error<E, C::Error>>
where
    C: Client,
    I: serde::Serialize,
    H: serde::Serialize,
    O: serde::de::DeserializeOwned,
    E: serde::de::DeserializeOwned,
{
    let body = serde_json::to_vec(&body).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestBody,
    })?;
    let body = bytes::Bytes::from(body);
    let headers = serde_json::to_value(&headers).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestHeaders,
    })?;

    let mut headers_serialized = std::collections::HashMap::new();
    match headers {
        serde_json::Value::Object(headers) => {
            for (k, v) in headers.into_iter() {
                let v_str = match v {
                    serde_json::Value::String(v) => v,
                    v => v.to_string(),
                };
                headers_serialized.insert(k, v_str);
            }
        }
        serde_json::Value::Null => {}
        _ => {
            return Err(Error::Protocol {
                info: "Headers must be an object".to_string(),
                stage: ProtocolErrorStage::SerializeRequestHeaders,
            });
        }
    }
    let (status, body) = client
        .request(&format!("{}{}", base_url, path), body, headers_serialized)
        .await
        .map_err(Error::Network)?;
    if status.is_success() {
        let output = serde_json::from_slice(&body).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::DeserializeResponseBody(body),
        })?;
        return Ok(output);
    }
    match serde_json::from_slice::<E>(&body) {
        Ok(error) => Err(Error::Application(error)),
        Err(e) if status.is_client_error() => Err(Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::DeserializeResponseError(status, body),
        }),
        Err(_) => Err(Error::Server(status, body)),
    }
}
