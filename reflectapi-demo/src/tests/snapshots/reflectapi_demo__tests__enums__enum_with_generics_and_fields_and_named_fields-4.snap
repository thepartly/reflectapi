---
source: reflectapi-demo/src/tests/enums.rs
expression: "super :: into_input_python_code :: <\nTestEnumWithGenericsAndFieldsAndNamedFields::<u8> > ()"
---
"""
Generated Python client for api_client.

DO NOT MODIFY THIS FILE MANUALLY.
This file is automatically generated by `reflectapi`.
""""

from __future__ import annotations


# Standard library imports
from enum import Enum
from typing import Annotated, Any, Generic, Optional, TypeVar, Union

# Third-party imports
from pydantic import BaseModel, ConfigDict, PrivateAttr, RootModel, model_serializer, model_validator

# Runtime imports
from reflectapi_runtime import AsyncClientBase, ClientBase, ApiResponse
from reflectapi_runtime import ReflectapiEmpty
from reflectapi_runtime import ReflectapiInfallible
from reflectapi_runtime.testing import MockClient, create_api_response


# Type variables for generic types


T = TypeVar("T")


T = TypeVar('T')

class ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant(BaseModel, Generic[T]):
    """Variant1 variant"""

    model_config = ConfigDict(extra="ignore", populate_by_name=True)

    field_0: int


class ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant(BaseModel, Generic[T]):
    """Variant2 variant"""

    model_config = ConfigDict(extra="ignore", populate_by_name=True)

    field_0: T
    field_1: T


class ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant(BaseModel, Generic[T]):
    """Variant3 variant"""

    model_config = ConfigDict(extra="ignore", populate_by_name=True)

    field1: int
    field2: T


# Externally tagged enum using RootModel
ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariants = Union[ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant[T], ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant[T], ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant[T]]

class ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields(RootModel[ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariants], Generic[T]):
    """Externally tagged enum"""

    @classmethod
    def __class_getitem__(cls, params):
        return cls


    @model_validator(mode='before')
    @classmethod
    def _validate_externally_tagged(cls, data):
        # Handle direct variant instances (for programmatic creation)
        if isinstance(data, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant):
            return data
        if isinstance(data, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant):
            return data
        if isinstance(data, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant):
            return data

        # Handle JSON data (for deserialization)


        if isinstance(data, dict):
            if len(data) != 1:
                raise ValueError("Externally tagged enum must have exactly one key")

            key, value = next(iter(data.items()))
            if key == "Variant1":
                return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant(field_0=value)
            if key == "Variant2":
                if isinstance(value, list):
                    return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant(field_0=value[0], field_1=value[1])
                else:
                    raise ValueError("Expected list for tuple variant Variant2")
            if key == "Variant3":
                return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant(**value)

        raise ValueError(f"Unknown variant for ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields: {data}")

    @model_serializer
    def _serialize_externally_tagged(self):
        if isinstance(self.root, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant):
            return {"Variant1": self.root.field_0}
        if isinstance(self.root, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant):
            return {"Variant2": [self.root.field_0, self.root.field_1]}
        if isinstance(self.root, ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant):
            return {"Variant3": self.root.model_dump(exclude_none=True)}

        raise ValueError(f"Cannot serialize ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields variant: {type(self.root)}")


class AsyncInputClient:
    """Async client for input_ operations."""

    def __init__(self, client: AsyncClientBase) -> None:
        self._client = client


    async def test(
        self,
        data: Optional[ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields[int]] = None,
    ) -> ApiResponse[Any]:
        """

        Args:
            data: Request data for the test operation.

        Returns:
            ApiResponse[Any]: Response containing Any data
        """
        path = "/input_test"

        params: dict[str, Any] = {}

        return await self._client._make_request(
            "POST",
            path,
            params=params if params else None,
            json_model=data,
            response_model=None,
)


class AsyncClient(AsyncClientBase):
    """Async client for the API."""

    def __init__(
        self,
        base_url: str,
        **kwargs: Any,
    ) -> None:
        super().__init__(base_url, **kwargs)

        self.input_ = AsyncInputClient(self)


class InputClient:
    """Synchronous client for input_ operations."""

    def __init__(self, client: ClientBase) -> None:
        self._client = client


    def test(
        self,
        data: Optional[ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields[int]] = None,
    ) -> ApiResponse[Any]:
        """

        Args:
            data: Request data for the test operation.

        Returns:
            ApiResponse[Any]: Response containing Any data
        """
        path = "/input_test"

        params: dict[str, Any] = {}

        return self._client._make_request(
            "POST",
            path,
            params=params if params else None,
            json_model=data,
            response_model=None,
)


class Client(ClientBase):
    """Synchronous client for the API."""

    def __init__(
        self,
        base_url: str,
        **kwargs: Any,
    ) -> None:
        super().__init__(base_url, **kwargs)

        self.input_ = InputClient(self)


# External type definitions
StdNumNonZeroU32 = Annotated[int, "Rust NonZero u32 type"]
StdNumNonZeroU64 = Annotated[int, "Rust NonZero u64 type"]
StdNumNonZeroI32 = Annotated[int, "Rust NonZero i32 type"]
StdNumNonZeroI64 = Annotated[int, "Rust NonZero i64 type"]

# Rebuild models to resolve forward references
try:
    ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields.model_rebuild()
except AttributeError:
    # Some types may not have model_rebuild method
    pass

# Factory classes (generated after model rebuild to avoid forward references)
class ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsFactory:
    """Factory class for creating ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields variants with ergonomic syntax.

    ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields variants
    ""

    @staticmethod
    def variant1(field_0) -> ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields[T]:
        """Creates the 'Variant1' variant of the ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields enum."""
        return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields(ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant1Variant[T](field_0=field_0))

    @staticmethod
    def variant2(field_0, field_1) -> ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields[T]:
        """Creates the 'Variant2' variant of the ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields enum."""
        return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields(ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant2Variant[T](field_0=field_0, field_1=field_1))

    @staticmethod
    def variant3(field1, field2) -> ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields[T]:
        """Creates the 'Variant3' variant of the ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields enum."""
        return ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields(ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFieldsVariant3Variant[T](field1=field1, field2=field2))


# Testing utilities


def create_reflectapidemotestsenumstestenumwithgenericsandfieldsandnamedfields_response(value: ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields) -> ApiResponse[ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields]:
    """Create a mock ApiResponse for ReflectapiDemoTestsEnumsTestEnumWithGenericsAndFieldsAndNamedFields."""
    return create_api_response(value)


def create_mock_client() -> MockClient:
    """Create a mock client for testing."""
    return MockClient()
