// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: Demo application
// This is a demo application

export function client(base: string | Client): __definition.Interface {
  return __implementation.__client(base);
}
/* <----- */
export interface RequestOptions {
  signal?: AbortSignal;
}

export interface Client {
  request(
    path: string,
    body: string,
    headers: Record<string, string>,
    options?: RequestOptions,
  ): Promise<[number, string]>;
}

export type NullToEmptyObject<T> = T extends null ? {} : T;

export type AsyncResult<T, E> = Promise<Result<T, Err<E>>>;

export type FixedSizeArray<T, N extends number> = Array<T> & { length: N };

export class Result<T, E> {
  constructor(private value: { ok: T } | { err: E }) {}

  public ok(): T | undefined {
    if ("ok" in this.value) {
      return this.value.ok;
    }
    return undefined;
  }
  public err(): E | undefined {
    if ("err" in this.value) {
      return this.value.err;
    }
    return undefined;
  }

  public is_ok(): boolean {
    return "ok" in this.value;
  }
  public is_err(): boolean {
    return "err" in this.value;
  }

  public map<U>(f: (r: T) => U): Result<U, E> {
    if ("ok" in this.value) {
      return new Result({ ok: f(this.value.ok) });
    } else {
      return new Result({ err: this.value.err });
    }
  }
  public map_err<U>(f: (r: E) => U): Result<T, U> {
    if ("err" in this.value) {
      return new Result({ err: f(this.value.err) });
    } else {
      return new Result({ ok: this.value.ok });
    }
  }

  public unwrap_ok(): T {
    if ("ok" in this.value) {
      return this.value.ok;
    }
    throw new Error(
      `called \`unwrap_ok\` on an \`err\` value: ${JSON.stringify(this.value.err)}`,
    );
  }
  public unwrap_err(): E {
    if ("err" in this.value) {
      return this.value.err;
    }
    throw new Error("called `unwrap_err` on an `ok` value");
  }

  public unwrap_ok_or_default(default_: T): T {
    if ("ok" in this.value) {
      return this.value.ok;
    }
    return default_;
  }
  public unwrap_err_or_default(default_: E): E {
    if ("err" in this.value) {
      return this.value.err;
    }
    return default_;
  }

  public unwrap_ok_or_else(f: (e: E) => T): T {
    if ("ok" in this.value) {
      return this.value.ok;
    }
    return f(this.value.err);
  }
  public unwrap_err_or_else(f: (v: T) => E): E {
    if ("err" in this.value) {
      return this.value.err;
    }
    return f(this.value.ok);
  }

  public toString(): string {
    if ("ok" in this.value) {
      return `Ok { ok: ${JSON.stringify(this.value.ok)} }`;
    } else {
      return `Err { err: ${JSON.stringify(this.value.err)} }`;
    }
  }
}

export class Err<E> {
  constructor(private value: { application_err: E } | { other_err: any }) {}

  public err(): E | undefined {
    if ("application_err" in this.value) {
      return this.value.application_err;
    }
    return undefined;
  }
  public other_err(): any | undefined {
    if ("other_err" in this.value) {
      return this.value.other_err;
    }
    return undefined;
  }

  public is_err(): boolean {
    return "application_err" in this.value;
  }
  public is_other_err(): boolean {
    return "other_err" in this.value;
  }

  public map<U>(f: (r: E) => U): Err<U> {
    if ("application_err" in this.value) {
      return new Err({ application_err: f(this.value.application_err) });
    } else {
      return new Err({ other_err: this.value.other_err });
    }
  }
  public unwrap(): E {
    if ("application_err" in this.value) {
      return this.value.application_err;
    } else {
      throw this.value.other_err;
    }
  }
  public unwrap_or_default(default_: E): E {
    if ("application_err" in this.value) {
      return this.value.application_err;
    }
    return default_;
  }
  public unwrap_or_else(f: () => E): E {
    if ("application_err" in this.value) {
      return this.value.application_err;
    }
    return f();
  }

  public toString(): string {
    if ("application_err" in this.value) {
      return `Application Error: ${JSON.stringify(this.value.application_err)}`;
    } else {
      return `Other Error: ${JSON.stringify(this.value.other_err)}`;
    }
  }
}

export function __request<I, H, O, E>(
  client: Client,
  path: string,
  input: I | undefined,
  headers: H | undefined,
  options?: RequestOptions,
): AsyncResult<O, E> {
  let hdrs: Record<string, string> = {
    "content-type": "application/json",
  };
  if (headers) {
    for (const [k, v] of Object.entries(headers)) {
      hdrs[k?.toString()] = v?.toString() || "";
    }
  }
  return client
    .request(path, JSON.stringify(input), hdrs, options)
    .then(([status, response_body]) => {
      if (status >= 200 && status < 300) {
        try {
          return new Result<O, Err<E>>({ ok: JSON.parse(response_body) as O });
        } catch (e) {
          return new Result<O, Err<E>>({
            err: new Err({
              other_err:
                "internal error: failure to parse response body as json on successful status code: " +
                response_body,
            }),
          });
        }
      } else if (status >= 500) {
        return new Result<O, Err<E>>({
          err: new Err({ other_err: `[${status}] ${response_body}` }),
        });
      } else {
        try {
          return new Result<O, Err<E>>({
            err: new Err({ application_err: JSON.parse(response_body) as E }),
          });
        } catch (e) {
          return new Result<O, Err<E>>({
            err: new Err({ other_err: `[${status}] ${response_body}` }),
          });
        }
      }
    })
    .catch((e) => {
      return new Result<O, Err<E>>({ err: new Err({ other_err: e }) });
    });
}

class ClientInstance {
  constructor(private base: string) {}

  public request(
    path: string,
    body: string,
    headers: Record<string, string>,
    options?: RequestOptions,
  ): Promise<[number, string]> {
    return (globalThis as any)
      .fetch(`${this.base}${path}`, {
        method: "POST",
        headers: headers,
        body: body,
        signal: options?.signal,
      })
      .then((response: any) => {
        return response.text().then((text: string) => {
          return [response.status, text];
        });
      });
  }
}

type UnionToIntersection<U> = (
  U extends any
    ? (k: U) => unknown
    : never
) extends (k: infer I) => void
  ? I
  : never;

// How it works:
// type Step0 =
// 	{ a: { x: string } }
// 	| { b: number }
// 	| 'c'

// First transformation:
// Turn the `string` variant into an object variant so each variant of the union is now uniform.
// type AfterStep1 =
// 	{ a: { x: string } }
// 	| { b: number }
// 	| { c: {} }

type Step1<T> = T extends object
  ? T
  : T extends string
    ? { [K in T]: unknown }
    : never;

// Second transformation:
// We want to merge the unions into a single object type.
// This is implemented by turning the union into an intersection.
// type AfterStep2 = {
// 	a: { x: string }
// 	b: number
// 	c: {}
// }

type Step2<T> = UnionToIntersection<T>;

// Final transformation:
// Turn each value type into a function that takes the value type as an argument and returns the result type.
// type AfterStep3<R> = {
// 	a: (arg: { x: string }) => R
// 	b: (arg: number) => R
// 	c: (arg: {}) => R
// }

type Step3<T, R> = { [K in keyof T]: (arg: T[K]) => R };

type Cases<T, R> = Step3<Step2<Step1<T>>, R>;

type CasesNonExhaustive<T, R> = Partial<Cases<T, R>>;

/**
 * Ergonomically and exhaustively handle all possible cases of a discriminated union
 * in the externally tagged representation (https://serde.rs/enum-representations.html).
 *
 * @example
 * ```typescript
 * type Status = 'loading' | { success: { data: string } } | { error: { message: string } };
 *
 * function handleStatus(status: Status) {
 *   return match(status, {
 *     loading: () => 'Loading...',
 *     success: ({ data }) => `Success: ${data}`,
 *     error: ({ message }) => `Error: ${message}`
 *   });
 * }
 *
 * // With default handler for non-exhaustive matching
 * function handleStatusWithDefault(status: Status) {
 *   return match(
 *     status,
 *     { loading: () => 'Loading...' },
 *     () => 'Unknown status'
 *   );
 * }
 * ```
 */
export function match<T extends object | string, R>(
  value: T,
  cases: Cases<T, R>,
): R;
export function match<T extends object | string, R>(
  value: T,
  cases: CasesNonExhaustive<T, R>,
  otherwise: () => R,
): R;
export function match<T extends object | string, R>(
  value: T,
  cases: Cases<T, R> | CasesNonExhaustive<T, R>,
  otherwise?: () => R,
): R {
  const branches = cases as Record<string, (arg: any) => R>;
  switch (typeof value) {
    case "string":
      if (value in branches) {
        return branches[value]({});
      }

      if (!otherwise) {
        throw new Error("otherwise must exist for non-exhaustive match");
      }
      return otherwise();

    case "object": {
      if (Object.keys(value).length !== 1) {
        throw new Error(
          "Expected object with exactly one key, see serde documentation for externally tagged enums above",
        );
      }

      const [k, v] = Object.entries(value)[0];
      if (k in branches) {
        return branches[k](v);
      }
      if (!otherwise) {
        throw new Error("otherwise must exist for non-exhaustive match");
      }
      return otherwise();
    }

    default:
      throw new Error("unreachable");
  }
}

/* -----> */

export namespace __definition {
  export interface Interface {
    health: HealthInterface;
    pets: PetsInterface;
  }

  export interface HealthInterface {
    /**
     * Check the health of the service
     */
    check: (
      input: {},
      headers: {},
      options?: RequestOptions,
    ) => AsyncResult<{}, {}>;
  }

  export interface PetsInterface {
    /**
     * List available pets
     */
    list: (
      input: myapi.proto.PetsListRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<
      myapi.proto.Paginated<myapi.model.output.Pet>,
      myapi.proto.PetsListError
    >;
    /**
     * Create a new pet
     */
    create: (
      input: myapi.proto.PetsCreateRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<{}, myapi.proto.PetsCreateError>;
    /**
     * Update an existing pet
     */
    update: (
      input: myapi.proto.PetsUpdateRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<{}, myapi.proto.PetsUpdateError>;
    /**
     * Remove an existing pet
     */
    remove: (
      input: myapi.proto.PetsRemoveRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<{}, myapi.proto.PetsRemoveError>;
    /**
     * @deprecated Use pets.remove instead
     * Remove an existing pet
     */
    delete: (
      input: myapi.proto.PetsRemoveRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<{}, myapi.proto.PetsRemoveError>;
    /**
     * Fetch first pet, if any exists
     */
    get_first: (
      input: {},
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) => AsyncResult<
      myapi.model.output.Pet | null,
      myapi.proto.UnauthorizedError
    >;
  }
}
export namespace myapi {
  export namespace model {
    export type Behavior =
      | "Calm"
      | {
          Aggressive: [
            /**
             * aggressiveness level
             */
            number /* f64 */,
            /**
             * some notes
             */
            string,
          ];
        }
      | {
          Other: {
            /**
             * Custom provided description of a behavior
             */
            description: string;
            /**
             * Additional notes
             * Up to a user to put free text here
             */
            notes?: string;
          };
        };

    export type Kind =
      /**
       * A dog
       */
      | {
          type: "dog";
          /**
           * breed of the dog
           */
          breed: string;
        }
      /**
       * A cat
       */
      | {
          type: "cat";
          /**
           * lives left
           */
          lives: number /* u8 */;
        };

    export namespace input {
      export interface Pet {
        /**
         * identity
         */
        name: string;
        /**
         * kind of pet
         */
        kind: myapi.model.Kind;
        /**
         * @deprecated test deprecation
         * age of the pet
         */
        age?: number /* u8 */ | null;
        updated_at?: string;
        /**
         * behaviors of the pet
         */
        behaviors?: Array<myapi.model.Behavior>;
      }
    }

    export namespace output {
      export interface Pet {
        /**
         * identity
         */
        name: string;
        /**
         * kind of pet
         */
        kind: myapi.model.Kind;
        /**
         * @deprecated test deprecation
         * age of the pet
         */
        age?: number /* u8 */ | null;
        updated_at: string;
        /**
         * behaviors of the pet
         */
        behaviors?: Array<myapi.model.Behavior>;
      }
    }
  }

  export namespace proto {
    export interface Headers {
      authorization: string;
    }

    export interface Paginated<T> {
      /**
       * slice of a collection
       */
      items: Array<T>;
      /**
       * cursor for getting next page
       */
      cursor?: string | null;
    }

    export type PetsCreateError =
      | "Conflict"
      | "NotAuthorized"
      | {
          InvalidIdentity: {
            message: string;
          };
        };

    export type PetsCreateRequest = myapi.model.input.Pet;

    export type PetsListError = "InvalidCursor" | "Unauthorized";

    export interface PetsListRequest {
      limit?: number /* u8 */ | null;
      cursor?: string | null;
    }

    export type PetsRemoveError = "NotFound" | "NotAuthorized";

    export interface PetsRemoveRequest {
      /**
       * identity
       */
      name: string;
    }

    export type PetsUpdateError = "NotFound" | "NotAuthorized";

    export interface PetsUpdateRequest {
      /**
       * identity
       */
      name: string;
      /**
       * kind of pet, non nullable in the model
       */
      kind?: myapi.model.Kind | null;
      /**
       * age of the pet, nullable in the model
       */
      age?: number /* u8 */ | null | undefined;
      /**
       * behaviors of the pet, nullable in the model
       */
      behaviors?: Array<myapi.model.Behavior> | null | undefined;
    }

    export type UnauthorizedError = null;
  }
}

export namespace reflectapi {
  /**
   * Struct object with no fields
   */
  export interface Empty {}

  /**
   * Error object which is expected to be never returned
   */
  export interface Infallible {}
}

namespace __implementation {
  /* <----- */

  export function __client(base: string | Client): __definition.Interface {
    const client_instance =
      typeof base === "string" ? new ClientInstance(base) : base;
    return {
      impl: {
        health: {
          check: health__check(client_instance),
        },
        pets: {
          list: pets__list(client_instance),
          create: pets__create(client_instance),
          update: pets__update(client_instance),
          remove: pets__remove(client_instance),
          delete: pets__delete(client_instance),
          get_first: pets__get_first(client_instance),
        },
      },
    }.impl;
  }

  /* -----> */

  function health__check(client: Client) {
    return (input: {}, headers: {}, options?: RequestOptions) =>
      __request<{}, {}, {}, {}>(
        client,
        "/health.check",
        input,
        headers,
        options,
      );
  }
  function pets__list(client: Client) {
    return (
      input: myapi.proto.PetsListRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        myapi.proto.PetsListRequest,
        myapi.proto.Headers,
        myapi.proto.Paginated<myapi.model.output.Pet>,
        myapi.proto.PetsListError
      >(client, "/pets.list", input, headers, options);
  }
  function pets__create(client: Client) {
    return (
      input: myapi.proto.PetsCreateRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        myapi.proto.PetsCreateRequest,
        myapi.proto.Headers,
        {},
        myapi.proto.PetsCreateError
      >(client, "/pets.create", input, headers, options);
  }
  function pets__update(client: Client) {
    return (
      input: myapi.proto.PetsUpdateRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        myapi.proto.PetsUpdateRequest,
        myapi.proto.Headers,
        {},
        myapi.proto.PetsUpdateError
      >(client, "/pets.update", input, headers, options);
  }
  function pets__remove(client: Client) {
    return (
      input: myapi.proto.PetsRemoveRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        myapi.proto.PetsRemoveRequest,
        myapi.proto.Headers,
        {},
        myapi.proto.PetsRemoveError
      >(client, "/pets.remove", input, headers, options);
  }
  function pets__delete(client: Client) {
    return (
      input: myapi.proto.PetsRemoveRequest,
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        myapi.proto.PetsRemoveRequest,
        myapi.proto.Headers,
        {},
        myapi.proto.PetsRemoveError
      >(client, "/pets.delete", input, headers, options);
  }
  function pets__get_first(client: Client) {
    return (
      input: {},
      headers: myapi.proto.Headers,
      options?: RequestOptions,
    ) =>
      __request<
        {},
        myapi.proto.Headers,
        myapi.model.output.Pet | null,
        myapi.proto.UnauthorizedError
      >(client, "/pets.get-first", input, headers, options);
  }
}
