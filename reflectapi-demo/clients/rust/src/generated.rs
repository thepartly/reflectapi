// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: Demo application
// This is a demo application


mod __definition {

pub struct Interface {
    #[serde(rename = "")]
    health: health.Interface,
    #[serde(rename = "")]
    pets: pets.Interface,
}

mod health {

pub struct Interface {
    /// Check the health of the service
    #[serde(rename = "")]
    check: (input: {}, headers: {})
        => Result<{}, {}>,
}

}

mod pets {

pub struct Interface {
    /// List available pets
    #[serde(rename = "")]
    list: (input: myapi::proto::PetsListRequest, headers: myapi::proto::Headers)
        => Result<myapi::proto::Paginated<myapi::model::Pet>, myapi::proto::PetsListError>,
    /// Create a new pet
    #[serde(rename = "")]
    create: (input: myapi::proto::PetsCreateRequest, headers: myapi::proto::Headers)
        => Result<{}, myapi::proto::PetsCreateError>,
    /// Update an existing pet
    #[serde(rename = "")]
    update: (input: myapi::proto::PetsUpdateRequest, headers: myapi::proto::Headers)
        => Result<{}, myapi::proto::PetsUpdateError>,
    /// Remove an existing pet
    #[serde(rename = "")]
    remove: (input: myapi::proto::PetsRemoveRequest, headers: myapi::proto::Headers)
        => Result<{}, myapi::proto::PetsRemoveError>,
    /// Fetch first pet, if any exists
    #[serde(rename = "")]
    get_first: (input: {}, headers: myapi::proto::Headers)
        => Result<std::option::Option<myapi::model::Pet>, myapi::proto::UnauthorizedError>,
}

}

}

pub trait Client<E> {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), E>;
}

pub enum Error<AE, NE> {
    Application(AE),
    Network(NE),
    Protocol {
        info: String,
        stage: ProtocolErrorStage,
    },
    Server(http::StatusCode, bytes::Bytes),
}

pub enum ProtocolErrorStage {
    SerializeRequestBody,
    SerializeRequestHeaders,
    DeserializeResponseBody(bytes::Bytes),
    DeserializeResponseError(http::StatusCode, bytes::Bytes),
}

#[cfg(feature = "reqwest")]
pub struct ReqwestClient {
    client: reqwest::Client,
    base_url: String,
}

#[cfg(feature = "reqwest")]
impl ReqwestClient {
    pub fn new(client: reqwest::Client, base_url: String) -> Self {
        Self { client, base_url }
    }
}

#[cfg(feature = "reqwest")]
impl Client<reqwest::Error> for ReqwestClient {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), reqwest::Error> {
        let url = format!("{}{}", self.base_url, path);
        let mut request = self.client.post(&url);
        for (k, v) in headers {
            request = request.header(k, v);
        }
        let response = request.body(body).send().await;
        let response = match response {
            Ok(response) => response,
            Err(e) => return Err(e),
        };
        let status = response.status();
        let body = response.bytes().await;
        let body = match body {
            Ok(body) => body,
            Err(e) => return Err(e),
        };
        Ok((status, body))
    }
}

mod myapi {

mod model {

pub type Behavior =
    | "Calm"
    | {
        Aggressive: [
            /// aggressiveness level
            f64,
            /// some notes
            std::string::String
        ]
    }
    | {
        Other: {
            /// Custom provided description of a behavior
            description: std::string::String,
            /// Additional notes
            /// Up to a user to put free text here
            #[serde(default)]
    notes: std::string::String
        }
    };

pub type Kind =
    /// A dog
    | "dog"
    /// A cat
    | "cat";

pub struct Pet {
    /// identity
    name: std::string::String,
    /// kind of pet
    kind: myapi::model::Kind,
    /// age of the pet
    #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
    age: std::option::Option<u8>,
    /// behaviors of the pet
    #[serde(default, skip_serializing_if = "std::vec::Vec::is_empty")]
    behaviors: std::vec::Vec<myapi::model::Behavior>,
}

}

mod proto {

pub struct Headers {
    authorization: std::string::String,
}

pub struct Paginated<T> {
    /// slice of a collection
    items: std::vec::Vec<T>,
    /// cursor for getting next page
    #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
    cursor: std::option::Option<std::string::String>,
}

pub type PetsCreateError =
    | "Conflict"
    | "NotAuthorized"
    | {
        InvalidIdentity: {
            message: std::string::String
        }
    };

pub type PetsCreateRequest = myapi::model::Pet;

pub type PetsListError =
    | "InvalidCustor"
    | "Unauthorized";

pub struct PetsListRequest {
    #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
    limit: std::option::Option<u8>,
    #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
    cursor: std::option::Option<std::string::String>,
}

pub type PetsRemoveError =
    | "NotFound"
    | "NotAuthorized";

pub struct PetsRemoveRequest {
    /// identity
    name: std::string::String,
}

pub type PetsUpdateError =
    | "NotFound"
    | "NotAuthorized";

pub struct PetsUpdateRequest {
    /// identity
    name: std::string::String,
    /// kind of pet, non nullable in the model
    #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
    kind: std::option::Option<myapi::model::Kind>,
    /// age of the pet, nullable in the model
    #[serde(default, skip_serializing_if = "reflectapi::Option::is_undefined")]
    age: reflectapi::Option<u8>,
    /// behaviors of the pet, nullable in the model
    #[serde(default, skip_serializing_if = "reflectapi::Option::is_undefined")]
    behaviors: reflectapi::Option<std::vec::Vec<myapi::model::Behavior>>,
}

pub type UnauthorizedError = ();

}

}

mod __implementation {
    async fn __request_impl<C, NE, I, H, O, E>(
        client: &C,
        path: &str,
        body: I,
        headers: H,
    ) -> Result<O, Error<E, NE>>
    where
        C: Client<NE>,
        I: serde::Serialize,
        H: serde::Serialize,
        O: serde::de::DeserializeOwned,
        E: serde::de::DeserializeOwned,
    {
        let body = serde_json::to_vec(&body).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::SerializeRequestBody,
        })?;
        let body = bytes::Bytes::from(body);
        let headers = serde_json::to_value(&headers).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::SerializeRequestHeaders,
        })?;

        let mut headers_serialized = HashMap::new();
        match headers {
            serde_json::Value::Object(headers) => {
                for (k, v) in headers.into_iter() {
                    let v_str = match v {
                        serde_json::Value::String(v) => v,
                        v => v.to_string(),
                    };
                    headers_serialized.insert(k, v_str);
                }
            }
            _ => {
                return Err(Error::Protocol {
                    info: "Headers must be an object".to_string(),
                    stage: ProtocolErrorStage::SerializeRequestHeaders,
                });
            }
        }
        let (status, body) = client
            .request(path, body, headers_serialized)
            .await
            .map_err(Error::Network)?;
        if status.is_success() {
            let output = serde_json::from_slice(&body).map_err(|e| Error::Protocol {
                info: e.to_string(),
                stage: ProtocolErrorStage::DeserializeResponseBody(body),
            })?;
            Ok(output)
        } else if status.is_client_error() {
            match serde_json::from_slice::<E>(&body) {
                Ok(error) => Err(Error::Application(error)),
                Err(e) => Err(Error::Protocol {
                    info: e.to_string(),
                    stage: ProtocolErrorStage::DeserializeResponseError(status, body),
                }),
            }
        } else {
            Err(Error::Server(status, body))
        }
    }
}

async fn health__check(&self, input: {}, headers: {})
        -> Result<{}, super::Error<{}, E>> {
            __request_impl(&self.client, "/health.check", input, headers).await
}
async fn pets__list(&self, input: myapi::proto::PetsListRequest, headers: myapi::proto::Headers)
        -> Result<myapi::proto::Paginated<myapi::model::Pet>, super::Error<myapi::proto::PetsListError, E>> {
            __request_impl(&self.client, "/pets.list", input, headers).await
}
async fn pets__create(&self, input: myapi::proto::PetsCreateRequest, headers: myapi::proto::Headers)
        -> Result<{}, super::Error<myapi::proto::PetsCreateError, E>> {
            __request_impl(&self.client, "/pets.create", input, headers).await
}
async fn pets__update(&self, input: myapi::proto::PetsUpdateRequest, headers: myapi::proto::Headers)
        -> Result<{}, super::Error<myapi::proto::PetsUpdateError, E>> {
            __request_impl(&self.client, "/pets.update", input, headers).await
}
async fn pets__remove(&self, input: myapi::proto::PetsRemoveRequest, headers: myapi::proto::Headers)
        -> Result<{}, super::Error<myapi::proto::PetsRemoveError, E>> {
            __request_impl(&self.client, "/pets.remove", input, headers).await
}
async fn pets__get_first(&self, input: {}, headers: myapi::proto::Headers)
        -> Result<std::option::Option<myapi::model::Pet>, super::Error<myapi::proto::UnauthorizedError, E>> {
            __request_impl(&self.client, "/pets.get-first", input, headers).await
}
