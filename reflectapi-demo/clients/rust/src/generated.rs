// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: Demo application
// This is a demo application

#![allow(non_camel_case_types)]

pub use interface::Interface;

mod interface {

    #[derive(serde::Serialize, serde::Deserialize)]
    pub struct Interface<E, C: super::Client<E>> {
        pub health: HealthInterface<E, C>,
        pub pets: PetsInterface<E, C>,
        client: C,
        base_url: std::string::String,
        marker: std::marker::PhantomData<E>,
    }

    #[derive(serde::Serialize, serde::Deserialize)]
    pub struct HealthInterface<E, C: super::Client<E>> {
        client: C,
        base_url: std::string::String,
        marker: std::marker::PhantomData<E>,
    }

    #[derive(serde::Serialize, serde::Deserialize)]
    pub struct PetsInterface<E, C: super::Client<E>> {
        client: C,
        base_url: std::string::String,
        marker: std::marker::PhantomData<E>,
    }
}

pub trait Client<E> {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), E>;
}

pub enum Error<AE, NE> {
    Application(AE),
    Network(NE),
    Protocol {
        info: String,
        stage: ProtocolErrorStage,
    },
    Server(http::StatusCode, bytes::Bytes),
}

pub enum ProtocolErrorStage {
    SerializeRequestBody,
    SerializeRequestHeaders,
    DeserializeResponseBody(bytes::Bytes),
    DeserializeResponseError(http::StatusCode, bytes::Bytes),
}

#[cfg(feature = "reqwest")]
impl Client<reqwest::Error> for reqwest::Client {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), reqwest::Error> {
        let mut request = self.post(path);
        for (k, v) in headers {
            request = request.header(k, v);
        }
        let response = request.body(body).send().await;
        let response = match response {
            Ok(response) => response,
            Err(e) => return Err(e),
        };
        let status = response.status();
        let body = response.bytes().await;
        let body = match body {
            Ok(body) => body,
            Err(e) => return Err(e),
        };
        Ok((status, body))
    }
}

mod types {

    mod myapi {

        mod model {

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum Behavior {
                Calm,
                Aggressive(
                    /// aggressiveness level
                    f64,
                    /// some notes
                    std::string::String,
                ),
                Other {
                    /// Custom provided description of a behavior
                    description: std::string::String,
                    /// Additional notes
                    /// Up to a user to put free text here
                    #[serde(default, skip_serializing_if = "std::string::String::is_empty")]
                    notes: std::string::String,
                },
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum Kind {
                /// A dog
                dog,
                /// A cat
                cat,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct Pet {
                /// identity
                pub name: std::string::String,
                /// kind of pet
                pub kind: super::super::myapi::model::Kind,
                /// age of the pet
                #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
                pub age: std::option::Option<u8>,
                /// behaviors of the pet
                #[serde(default, skip_serializing_if = "std::vec::Vec::is_empty")]
                pub behaviors: std::vec::Vec<super::super::myapi::model::Behavior>,
            }
        }

        mod proto {

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct Headers {
                pub authorization: std::string::String,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct Paginated<T> {
                /// slice of a collection
                pub items: std::vec::Vec<T>,
                /// cursor for getting next page
                #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
                pub cursor: std::option::Option<std::string::String>,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum PetsCreateError {
                Conflict,
                NotAuthorized,
                InvalidIdentity { message: std::string::String },
            }

            pub type PetsCreateRequest = super::super::myapi::model::Pet;

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum PetsListError {
                InvalidCustor,
                Unauthorized,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct PetsListRequest {
                #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
                pub limit: std::option::Option<u8>,
                #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
                pub cursor: std::option::Option<std::string::String>,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum PetsRemoveError {
                NotFound,
                NotAuthorized,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct PetsRemoveRequest {
                /// identity
                pub name: std::string::String,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub enum PetsUpdateError {
                NotFound,
                NotAuthorized,
            }

            #[derive(serde::Serialize, serde::Deserialize)]
            pub struct PetsUpdateRequest {
                /// identity
                pub name: std::string::String,
                /// kind of pet, non nullable in the model
                #[serde(default, skip_serializing_if = "std::option::Option::is_none")]
                pub kind: std::option::Option<super::super::myapi::model::Kind>,
                /// age of the pet, nullable in the model
                #[serde(default, skip_serializing_if = "reflectapi::Option::is_undefined")]
                pub age: reflectapi::Option<u8>,
                /// behaviors of the pet, nullable in the model
                #[serde(default, skip_serializing_if = "reflectapi::Option::is_undefined")]
                pub behaviors:
                    reflectapi::Option<std::vec::Vec<super::super::myapi::model::Behavior>>,
            }

            pub struct UnauthorizedError;
        }
    }
}

async fn __request_impl<C, NE, I, H, O, E>(
    client: &C,
    path: &str,
    body: I,
    headers: H,
) -> Result<O, Error<E, NE>>
where
    C: Client<NE>,
    I: serde::Serialize,
    H: serde::Serialize,
    O: serde::de::DeserializeOwned,
    E: serde::de::DeserializeOwned,
{
    let body = serde_json::to_vec(&body).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestBody,
    })?;
    let body = bytes::Bytes::from(body);
    let headers = serde_json::to_value(&headers).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestHeaders,
    })?;

    let mut headers_serialized = std::collections::HashMap::new();
    match headers {
        serde_json::Value::Object(headers) => {
            for (k, v) in headers.into_iter() {
                let v_str = match v {
                    serde_json::Value::String(v) => v,
                    v => v.to_string(),
                };
                headers_serialized.insert(k, v_str);
            }
        }
        _ => {
            return Err(Error::Protocol {
                info: "Headers must be an object".to_string(),
                stage: ProtocolErrorStage::SerializeRequestHeaders,
            });
        }
    }
    let (status, body) = client
        .request(path, body, headers_serialized)
        .await
        .map_err(Error::Network)?;
    if status.is_success() {
        let output = serde_json::from_slice(&body).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::DeserializeResponseBody(body),
        })?;
        Ok(output)
    } else if status.is_client_error() {
        match serde_json::from_slice::<E>(&body) {
            Ok(error) => Err(Error::Application(error)),
            Err(e) => Err(Error::Protocol {
                info: e.to_string(),
                stage: ProtocolErrorStage::DeserializeResponseError(status, body),
            }),
        }
    } else {
        Err(Error::Server(status, body))
    }
}

async fn health__check(&self, input: (), headers: ()) -> Result<(), Error<(), E>> {
    __request_impl(&self.client, "/health.check", input, headers).await
}
async fn pets__list(
    &self,
    input: super::myapi::proto::PetsListRequest,
    headers: super::myapi::proto::Headers,
) -> Result<
    super::myapi::proto::Paginated<super::myapi::model::Pet>,
    Error<super::myapi::proto::PetsListError, E>,
> {
    __request_impl(&self.client, "/pets.list", input, headers).await
}
async fn pets__create(
    &self,
    input: super::myapi::proto::PetsCreateRequest,
    headers: super::myapi::proto::Headers,
) -> Result<(), Error<super::myapi::proto::PetsCreateError, E>> {
    __request_impl(&self.client, "/pets.create", input, headers).await
}
async fn pets__update(
    &self,
    input: super::myapi::proto::PetsUpdateRequest,
    headers: super::myapi::proto::Headers,
) -> Result<(), Error<super::myapi::proto::PetsUpdateError, E>> {
    __request_impl(&self.client, "/pets.update", input, headers).await
}
async fn pets__remove(
    &self,
    input: super::myapi::proto::PetsRemoveRequest,
    headers: super::myapi::proto::Headers,
) -> Result<(), Error<super::myapi::proto::PetsRemoveError, E>> {
    __request_impl(&self.client, "/pets.remove", input, headers).await
}
async fn pets__get_first(
    &self,
    input: (),
    headers: super::myapi::proto::Headers,
) -> Result<
    std::option::Option<super::myapi::model::Pet>,
    Error<super::myapi::proto::UnauthorizedError, E>,
> {
    __request_impl(&self.client, "/pets.get-first", input, headers).await
}
