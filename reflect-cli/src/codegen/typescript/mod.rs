use std::{fmt::format, io::Write};

use anyhow::Context;

use askama::Template; // bring trait in scope

#[derive(Template)]
#[template(
    source = "/**
 * DO NOT MODIFY THIS FILE MANUALLY
 * This file was generated by reflect-cli
 *
 * Schema name: {{ name }}
 * {{ description }}
 */
",
    ext = "txt"
)]
struct FileTemplate {
    name: String,
    description: String,
}

#[derive(Template)]
#[template(
    source = "{{ description }}interface {{ name }} {
    {% for field in fields.iter() -%}
    {{ field }};
    {% endfor -%}
}
",
    ext = "txt"
)]
struct StructTemplate {
    name: String,
    description: String,
    fields: Vec<FieldTemplate>,
}

#[derive(Template)]
#[template(source = "{{ description }}{{ name }}: {{ type_ }}", ext = "txt")]
struct FieldTemplate {
    name: String,
    description: String,
    type_: String,
}

#[derive(Template)]
#[template(
    source = "
type {{ name }} =
    {% for variant in variants.iter() -%}
    {{ description }}{{ variant }} |
    {% endfor %};
",
    ext = "txt"
)]
struct EnumTemplate {
    name: String,
    description: String,
    variants: Vec<VariantTemplate>,
}

#[derive(Template)]
#[template(source = "{{ description }}{{ name }}", ext = "txt")]
struct VariantTemplate {
    name: String,
    description: String,
}

#[derive(Template)]
#[template(
    source = "{{ description }}type {{ name }} = {{ type_ }};
",
    ext = "txt"
)]
struct PrimitiveTemplate {
    name: String,
    description: String,
    type_: String,
}

pub fn generate(schema: reflect::Schema, output: Option<std::path::PathBuf>) -> anyhow::Result<()> {
    let output = output.unwrap_or_else(|| std::path::PathBuf::from("./"));
    let output = output.join("index.ts");
    let mut file = std::fs::File::create(output).context("Failed to create file")?;

    let file_template = FileTemplate {
        name: schema.name,
        description: schema.description,
    };
    let mut generated_code = vec![];
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    for type_def in schema.types {
        let type_name = type_to_ts_name(&type_def);
        match type_def {
            reflect::Type::Struct(struct_def) => {
                let struct_template = StructTemplate {
                    name: type_name,
                    description: doc_to_ts_comments(&struct_def.description, 0),
                    fields: struct_def
                        .fields
                        .iter()
                        .map(|field| FieldTemplate {
                            name: field.name.clone(),
                            description: doc_to_ts_comments(&field.description, 4),
                            type_: type_ref_to_ts_ref(&field.type_ref),
                        })
                        .collect::<Vec<_>>(),
                };
                generated_code.push(
                    struct_template
                        .render()
                        .context("Failed to render template")?,
                );
            }
            reflect::Type::Enum(enum_def) => {
                let enum_template = EnumTemplate {
                    name: type_name,
                    description: doc_to_ts_comments(&enum_def.description, 0),
                    variants: enum_def
                        .variants
                        .iter()
                        .map(|variant| VariantTemplate {
                            name: variant.name.clone(),
                            description: doc_to_ts_comments(&variant.description, 4),
                        })
                        .collect::<Vec<_>>(),
                };
                generated_code.push(
                    enum_template
                        .render()
                        .context("Failed to render template")?,
                );
            }
            reflect::Type::Primitive(type_def) => {
                let primitive_template = PrimitiveTemplate {
                    name: type_name,
                    description: doc_to_ts_comments(&type_def.description, 0),
                    type_: "TODO".into(),
                };
                generated_code.push(
                    primitive_template
                        .render()
                        .context("Failed to render template")?,
                );
            }
        }
    }

    let generated_code = generated_code.join("\n");
    println!("{}", generated_code);
    file.write(generated_code.as_bytes())
        .context("Failed to write to file")?;

    Ok(())
}

fn type_ref_to_ts_ref(type_ref: &reflect::TypeReference) -> String {
    let n = type_ref.name.replace("::", ".");
    let p = type_ref_params_to_ts_ref(&type_ref.parameters);
    format!("{}{}", n, p)
}

fn type_ref_params_to_ts_ref(type_params: &Vec<reflect::TypeReference>) -> String {
    let p = type_params
        .iter()
        .map(|type_ref| type_ref_to_ts_ref(type_ref))
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn type_to_ts_name(type_: &reflect::Type) -> String {
    let n = type_.name().replace("::", ".");
    let p = type_params_to_ts_name(type_.parameters());
    format!("{}{}", n, p)
}

fn type_params_to_ts_name(type_params: std::slice::Iter<'_, reflect::TypeParameter>) -> String {
    let p = type_params
        .map(|type_param| type_param.name.clone())
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn doc_to_ts_comments(doc: &String, offset: u8) -> String {
    if doc.is_empty() {
        return "".into();
    }
    let offset = " ".repeat(offset as usize);
    let doc = doc
        .split("\n")
        .map(|line| format!("{} * {}", offset, line))
        .collect::<Vec<_>>()
        .join("\n");
    format!("/**\n{}\n{} */\n{}", doc, offset, offset)
}
