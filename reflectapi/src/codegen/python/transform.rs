use crate::codegen::python::{
    semantic::{
        DiscriminatedUnionDef, EndpointDef, FactoryDef, HttpMethod, ModelDef, PySemanticIR,
        PySemanticType, RootModelDef, SerializationStrategy, TypeAliasDef, ValidationStrategy,
    },
    syntax::{
        Argument, ArgumentKind, Class, Decorator, Expression, Field, Function, Import, ImportBlock,
        ImportName, Item, Module, Statement, TypeAlias, TypeExpr,
    },
};
/// Python IR Transformation Pipeline
///
/// This module transforms Python semantic IR (high-level modeling decisions)
/// into Python syntax IR (concrete code structures). It bridges the gap between
/// "what to generate" and "how to structure the code".
///
/// Key transformations:
/// - DiscriminatedUnion -> TypeAlias + BaseModel classes
/// - RootModelWrapper -> RootModel class with validators
/// - FactoryPattern -> Factory class with static methods
/// - SimpleModel -> BaseModel class with fields

/// Transforms semantic IR into syntax IR
pub struct PySyntaxTransform;

impl PySyntaxTransform {
    pub fn new() -> Self {
        Self
    }

    /// Transform Python semantic IR into a syntax module
    pub fn transform(&self, semantic: PySemanticIR) -> Module {
        let mut module = Module::new(semantic.package_name.clone());
        // Temporarily disable module docstring to fix literal \n issue
        // module.docstring = Some(format!(
        //     "Generated Python client for {}.\n\nDO NOT MODIFY THIS FILE MANUALLY.\nThis file is automatically generated by ReflectAPI.",
        //     semantic.package_name
        // ));

        // Add future imports
        module.future_imports.push("annotations".to_string());

        // Build import block
        module.imports = self.build_imports(&semantic);

        // First pass: Collect all unique TypeVar names needed across the entire semantic IR
        let type_var_names = self.collect_required_type_vars(&semantic);
        
        // Add TypeVar definitions at the beginning (after imports, before any classes)
        for type_var_name in type_var_names {
            // Sanitize TypeVar name for use as Python identifier
            let sanitized_name = self.sanitize_type_var_name(&type_var_name);
            
            let type_var_assignment = Item::Assignment(crate::codegen::python::syntax::Assignment {
                target: sanitized_name.clone(),
                value: Expression::call(
                    Expression::name("TypeVar"),
                    vec![Expression::string(&sanitized_name)],
                ),
                type_annotation: None,
            });
            module.add_item(type_var_assignment);
        }

        // Second pass: Transform types in the order they come from semantic layer
        // (which is already topologically sorted to respect dependencies)
        for (_name, semantic_type) in &semantic.types {
            let items = self.transform_type(semantic_type.clone());
            for item in items {
                module.add_item(item);
            }
        }

        // Third pass: Transform endpoints into client classes
        for (service_name, endpoints) in &semantic.endpoints {
            let client_class = self.build_client_class(service_name, endpoints.clone(), &semantic);
            module.add_item(Item::Class(client_class));
        }

        module
    }

    fn build_imports(&self, semantic: &PySemanticIR) -> ImportBlock {
        let mut imports = ImportBlock::default();

        // Standard library imports
        let mut std_imports = Vec::new();

        if semantic.required_imports.has_datetime {
            std_imports.push("datetime");
        }
        if semantic.required_imports.has_uuid {
            std_imports.push("uuid");
        }
        if semantic.required_imports.has_enums {
            std_imports.push("enum");
        }

        for import_name in std_imports {
            imports.standard.push(Import::Simple {
                module: import_name.to_string(),
                alias: None,
            });
        }

        // Typing imports
        let mut typing_names = vec!["Any", "Optional", "TypeVar", "Generic", "Union"];

        if semantic.required_imports.has_annotated {
            typing_names.push("Annotated");
        }
        if semantic.required_imports.has_literal {
            typing_names.push("Literal");
        }

        imports.standard.push(Import::From {
            module: "typing".to_string(),
            names: typing_names
                .into_iter()
                .map(|name| ImportName {
                    name: name.to_string(),
                    alias: None,
                })
                .collect(),
        });

        // Pydantic imports
        let mut pydantic_names = vec!["BaseModel", "ConfigDict"];

        if semantic.required_imports.has_discriminated_unions {
            pydantic_names.push("Field");
        }
        if semantic.required_imports.has_externally_tagged_enums {
            pydantic_names.extend(&["RootModel", "model_validator", "model_serializer"]);
        }

        imports.third_party.push(Import::From {
            module: "pydantic".to_string(),
            names: pydantic_names
                .into_iter()
                .map(|name| ImportName {
                    name: name.to_string(),
                    alias: None,
                })
                .collect(),
        });

        // ReflectAPI runtime imports
        let mut runtime_imports = Vec::new();

        if semantic.config.generate_async && semantic.config.generate_sync {
            runtime_imports.extend(&["AsyncClientBase", "ClientBase", "ApiResponse"]);
        } else if semantic.config.generate_async {
            runtime_imports.extend(&["AsyncClientBase", "ApiResponse"]);
        } else if semantic.config.generate_sync {
            runtime_imports.extend(&["ClientBase", "ApiResponse"]);
        }

        if semantic.required_imports.has_reflectapi_option {
            runtime_imports.push("ReflectapiOption");
        }
        if semantic.required_imports.has_reflectapi_empty {
            runtime_imports.push("ReflectapiEmpty");
        }
        if semantic.required_imports.has_reflectapi_infallible {
            runtime_imports.push("ReflectapiInfallible");
        }

        if !runtime_imports.is_empty() {
            imports.third_party.push(Import::From {
                module: "reflectapi_runtime".to_string(),
                names: runtime_imports
                    .into_iter()
                    .map(|name| ImportName {
                        name: name.to_string(),
                        alias: None,
                    })
                    .collect(),
            });
        }

        // Testing imports
        if semantic.config.generate_testing {
            imports.third_party.push(Import::From {
                module: "reflectapi_runtime.testing".to_string(),
                names: vec![
                    ImportName {
                        name: "MockClient".to_string(),
                        alias: None,
                    },
                    ImportName {
                        name: "create_api_response".to_string(),
                        alias: None,
                    },
                ],
            });
        }

        imports
    }

    fn transform_type(&self, semantic_type: PySemanticType) -> Vec<Item> {
        match semantic_type {
            PySemanticType::SimpleModel(model) => self.transform_simple_model(model),
            PySemanticType::DiscriminatedUnion(union) => self.transform_discriminated_union(union),
            PySemanticType::RootModelWrapper(wrapper) => self.transform_root_model_wrapper(wrapper),
            PySemanticType::FactoryPattern(factory) => self.transform_factory_pattern(factory),
            PySemanticType::TypeAlias(alias) => self.transform_type_alias(alias),
            // TODO: Implement other semantic types
            _ => vec![],
        }
    }

    fn transform_simple_model(&self, model: ModelDef) -> Vec<Item> {
        let mut class = Class::new(model.name.clone());
        // Temporarily disable docstrings to fix literal \n issue
        // class.docstring = Some(clean_description_for_docstring(&model.description));

        // Add base classes
        for base in model.base_classes {
            class.add_base(TypeExpr::name(&base));
        }

        // Add generic parameters
        if !model.generic_params.is_empty() {
            class.meta.is_generic = true;
            class.meta.type_params = model.generic_params;
        }

        // Add fields
        for (_, field_def) in model.fields {
            let field = Field {
                name: field_def.python_name,
                type_annotation: self.parse_type_annotation(&field_def.type_annotation),
                default: field_def.default_value.map(|v| Expression::name(&v)),
                field_config: field_def.field_config.map(|_| {
                    // TODO: Build Field(...) expression from config
                    Expression::call(Expression::name("Field"), vec![])
                }),
            };
            class.add_field(field);
        }

        vec![Item::Class(class)]
    }

    fn transform_discriminated_union(&self, union: DiscriminatedUnionDef) -> Vec<Item> {
        let mut items = Vec::new();

        // Create variant classes first
        eprintln!("DEBUG: Processing discriminated union '{}' with {} variants", union.name, union.variants.len());
        let mut variant_class_names = Vec::new();
        for (tag, variant_type) in &union.variants {
            eprintln!("DEBUG: Processing variant '{}' of type {:?}", tag, variant_type);
            // Recursively transform variant types
            let variant_items = self.transform_type(variant_type.clone());
            eprintln!("DEBUG: Generated {} items for variant '{}'", variant_items.len(), tag);
            
            // Extract variant class name for Union type
            if let PySemanticType::SimpleModel(model) = variant_type {
                // Add discriminator field to each variant model
                // This needs to be done during variant class creation
                variant_class_names.push(model.name.clone());
            }
            
            items.extend(variant_items);
        }

        // For internally tagged discriminated unions in Pydantic v2:
        // We create a type alias with Annotated[Union[...], Field(discriminator='field_name')]
        
        // Build the Union type annotation
        let union_type = if variant_class_names.is_empty() {
            TypeExpr::name("Any")
        } else {
            TypeExpr::union(
                variant_class_names
                    .iter()
                    .map(|name| TypeExpr::name(name))
                    .collect()
            )
        };

        // Create a type alias with the annotated union
        let annotated_union = TypeExpr::Annotated {
            base: Box::new(union_type),
            metadata: vec![
                Expression::Call {
                    func: Box::new(Expression::name("Field")),
                    args: vec![],
                    kwargs: vec![(
                        "discriminator".to_string(),
                        Expression::string(&union.discriminator_field)
                    )],
                }
            ],
        };

        // Create the type alias
        let type_alias = TypeAlias {
            name: union.name.clone(),
            type_params: vec![],
            value: annotated_union,
        };

        items.push(Item::TypeAlias(type_alias));
        items
    }

    fn transform_root_model_wrapper(&self, wrapper: RootModelDef) -> Vec<Item> {
        let mut items = Vec::new();

        // Create the main wrapper class
        let mut class = Class::new(wrapper.name.clone());
        // Temporarily disable docstrings to fix literal \n issue
        // class.docstring = Some(clean_description_for_docstring(&wrapper.description));

        // Add RootModel base with union type
        class.add_base(TypeExpr::generic(
            "RootModel",
            vec![self.parse_type_annotation(&wrapper.union_type)],
        ));

        // Add validation method based on strategy
        match wrapper.validation_strategy {
            ValidationStrategy::OrderedUnion { precedence: _ } => {
                let validator = self.build_ordered_union_validator();
                class.add_method(validator);
            }
            ValidationStrategy::CustomValidator { logic } => {
                let validator =
                    self.build_custom_validator(&logic.method_name, &logic.implementation);
                class.add_method(validator);
            }
            _ => {}
        }

        // Add serialization method based on strategy
        match wrapper.serialization_strategy {
            SerializationStrategy::WrappedDict => {
                let serializer = self.build_wrapped_dict_serializer();
                class.add_method(serializer);
            }
            SerializationStrategy::Custom { logic } => {
                let serializer =
                    self.build_custom_serializer(&logic.method_name, &logic.implementation);
                class.add_method(serializer);
            }
            _ => {}
        }

        items.push(Item::Class(class));

        // Create factory class if needed
        if wrapper.requires_factory && !wrapper.variant_models.is_empty() {
            let factory = self.build_enum_factory(&wrapper.name, &wrapper.variant_models);
            // Only add factory if it has content
            if !factory.fields.is_empty() || !factory.methods.is_empty() {
                items.push(Item::Class(factory));
            }
        }

        items
    }

    fn transform_factory_pattern(&self, factory: FactoryDef) -> Vec<Item> {
        let mut class = Class::new(format!("{}Factory", factory.name));

        // Add constants
        for constant in factory.constants {
            let field = Field {
                name: constant.name,
                type_annotation: TypeExpr::name(&constant.type_annotation),
                default: Some(Expression::name(&constant.value)),
                field_config: None,
            };
            class.add_field(field);
        }

        // Add static methods
        for method_def in factory.static_methods {
            let mut method = Function::new(method_def.name);
            method.is_static = true;
            method.return_type = Some(TypeExpr::name(&method_def.return_type));

            // Add parameters
            for param in method_def.parameters {
                method.add_arg(Argument {
                    name: param.name,
                    type_annotation: Some(TypeExpr::name(&param.type_annotation)),
                    default: param.default_value.map(|v| Expression::name(&v)),
                    kind: ArgumentKind::Positional,
                });
            }

            // Add body (simplified - would need proper template parsing)
            method.add_statement(Statement::Return(Some(Expression::name("result"))));

            class.add_method(method);
        }

        vec![Item::Class(class)]
    }

    fn transform_type_alias(&self, alias: TypeAliasDef) -> Vec<Item> {
        let type_alias = TypeAlias {
            name: alias.name,
            type_params: vec![],
            value: TypeExpr::name(&alias.target_type),
        };

        vec![Item::TypeAlias(type_alias)]
    }

    fn build_client_class(
        &self,
        service_name: &str,
        endpoints: Vec<EndpointDef>,
        semantic: &PySemanticIR,
    ) -> Class {
        let class_name = format!("{}Client", capitalize_first(service_name));
        let mut class = Class::new(class_name);

        // Choose base class based on configuration
        let base_class = if semantic.config.generate_async && semantic.config.generate_sync {
            "ClientBase" // Assume ClientBase supports both sync and async
        } else if semantic.config.generate_async {
            "AsyncClientBase"
        } else {
            "ClientBase"
        };

        class.add_base(TypeExpr::name(base_class));

        // Add endpoint methods
        for endpoint in endpoints {
            let method = self.build_endpoint_method(endpoint, semantic.config.generate_async);
            class.add_method(method);
        }

        class
    }

    fn build_endpoint_method(&self, endpoint: EndpointDef, is_async: bool) -> Function {
        let mut method = Function::new(endpoint.client_method_name);
        method.is_async = is_async;

        // Add self parameter (required for all instance methods)
        method.add_arg(Argument {
            name: "self".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Add input parameter if present
        if let Some(input_type) = endpoint.input_type {
            method.add_arg(Argument {
                name: "input".to_string(),
                type_annotation: Some(TypeExpr::name(&input_type)),
                default: None,
                kind: ArgumentKind::Positional,
            });
        }

        // Set return type
        if let Some(output_type) = endpoint.output_type {
            method.return_type = Some(TypeExpr::generic(
                "ApiResponse",
                vec![TypeExpr::name(&output_type)],
            ));
        } else {
            method.return_type = Some(TypeExpr::generic(
                "ApiResponse",
                vec![TypeExpr::name("None")],
            ));
        }

        // Add method body (simplified)
        let http_method = match endpoint.method {
            HttpMethod::Get => "GET",
            HttpMethod::Post => "POST",
            HttpMethod::Put => "PUT",
            HttpMethod::Delete => "DELETE",
            HttpMethod::Patch => "PATCH",
        };

        let call_expr = if is_async {
            Expression::call(
                Expression::attr(Expression::name("self"), "_request_async"),
                vec![
                    Expression::string(http_method),
                    Expression::string(&endpoint.path),
                ],
            )
        } else {
            Expression::call(
                Expression::attr(Expression::name("self"), "_request"),
                vec![
                    Expression::string(http_method),
                    Expression::string(&endpoint.path),
                ],
            )
        };

        method.add_statement(Statement::Return(Some(call_expr)));

        method
    }

    fn build_ordered_union_validator(&self) -> Function {
        let mut validator = Function::new("_validate".to_string());
        validator.add_decorator(Decorator {
            name: "model_validator".to_string(),
            args: vec![],
            kwargs: vec![("mode".to_string(), Expression::string("before"))],
        });
        validator.add_decorator(Decorator {
            name: "classmethod".to_string(),
            args: vec![],
            kwargs: vec![],
        });

        validator.add_arg(Argument {
            name: "cls".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });
        validator.add_arg(Argument {
            name: "data".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Add validation logic (simplified)
        validator.add_statement(Statement::Return(Some(Expression::name("data"))));

        validator
    }

    fn build_custom_validator(&self, method_name: &str, implementation: &str) -> Function {
        let mut validator = Function::new(method_name.to_string());

        // Add decorators
        validator.add_decorator(Decorator {
            name: "model_validator".to_string(),
            args: vec![],
            kwargs: vec![("mode".to_string(), Expression::string("before"))],
        });
        validator.add_decorator(Decorator {
            name: "classmethod".to_string(),
            args: vec![],
            kwargs: vec![],
        });

        // Add cls parameter for classmethod
        validator.add_arg(Argument {
            name: "cls".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Add data parameter
        validator.add_arg(Argument {
            name: "data".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Build the implementation statement
        let stmt = if implementation.trim().starts_with("return") {
            Statement::Return(Some(Expression::name(
                implementation.trim().strip_prefix("return").unwrap().trim(),
            )))
        } else {
            Statement::Expression(Expression::name(implementation))
        };

        validator.add_statement(stmt);
        validator
    }

    fn build_wrapped_dict_serializer(&self) -> Function {
        let mut serializer = Function::new("_serialize".to_string());
        serializer.add_decorator(Decorator {
            name: "model_serializer".to_string(),
            args: vec![],
            kwargs: vec![],
        });

        serializer.add_arg(Argument {
            name: "self".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Add serialization logic for wrapped dict
        serializer.add_statement(Statement::Return(Some(Expression::name("self.root"))));

        serializer
    }

    fn build_custom_serializer(&self, method_name: &str, implementation: &str) -> Function {
        let mut serializer = Function::new(method_name.to_string());

        // Add decorator
        serializer.add_decorator(Decorator {
            name: "model_serializer".to_string(),
            args: vec![],
            kwargs: vec![],
        });

        // Add self parameter
        serializer.add_arg(Argument {
            name: "self".to_string(),
            type_annotation: None,
            default: None,
            kind: ArgumentKind::Positional,
        });

        // Build the implementation statement
        let stmt = if implementation.trim().starts_with("return") {
            Statement::Return(Some(Expression::name(
                implementation.trim().strip_prefix("return").unwrap().trim(),
            )))
        } else {
            Statement::Expression(Expression::name(implementation))
        };

        serializer.add_statement(stmt);
        serializer
    }

    fn build_enum_factory(&self, enum_name: &str, variant_models: &[String]) -> Class {
        let factory_name = format!("{}Factory", enum_name);
        let mut class = Class::new(factory_name);
        
        // Temporarily disable docstrings to fix literal \n issue
        // class.docstring = Some(format!("Factory methods for creating {} instances", enum_name));
        
        // Add factory methods for each variant (if any)
        for variant_name in variant_models {
            // Clean up variant name for method naming
            let clean_variant = variant_name
                .replace("Literal[\"", "")
                .replace("\"]", "")
                .replace("\"", "")
                .replace("[", "_")
                .replace("]", "_")
                .replace(" ", "_")
                .replace("-", "_")
                .chars()
                .filter(|c| c.is_alphanumeric() || *c == '_')
                .collect::<String>();
            
            let method_name = format!("create_{}", clean_variant.to_lowercase());
            let mut method = Function::new(method_name);
            method.is_classmethod = true;
            method.return_type = Some(TypeExpr::name(enum_name));
            
            // Add basic implementation
            method.add_statement(Statement::Return(Some(Expression::name("NotImplemented"))));
            class.add_method(method);
        }
        
        class
    }

    /// Collect all TypeVar names required by scanning the semantic IR
    fn collect_required_type_vars(&self, semantic: &PySemanticIR) -> Vec<String> {
        let mut used_type_params = std::collections::HashSet::new();
        
        // First, collect all class names to avoid conflicts
        let mut class_names = std::collections::HashSet::new();
        for (name, _) in &semantic.types {
            class_names.insert(name.clone());
        }
        
        // Scan all semantic types for generic parameters
        for (_name, semantic_type) in &semantic.types {
            self.collect_type_vars_from_semantic_type(semantic_type, &mut used_type_params);
        }
        
        // Scan endpoints for type parameters in input/output types
        for endpoints in semantic.endpoints.values() {
            for endpoint in endpoints {
                if let Some(input_type) = &endpoint.input_type {
                    self.extract_type_vars_from_annotation(input_type, &mut used_type_params);
                }
                if let Some(output_type) = &endpoint.output_type {
                    self.extract_type_vars_from_annotation(output_type, &mut used_type_params);
                }
            }
        }
        
        // Filter out any type parameters that conflict with class names
        // For conflicts, we'll only create TypeVars for actual generic parameters, not class names
        let mut type_vars: Vec<String> = used_type_params
            .into_iter()
            .filter(|name| !class_names.contains(name))
            .collect();
        type_vars.sort();
        type_vars
    }

    /// Extract TypeVar names from semantic types
    fn collect_type_vars_from_semantic_type(&self, semantic_type: &PySemanticType, used_params: &mut std::collections::HashSet<String>) {
        match semantic_type {
            PySemanticType::SimpleModel(model) => {
                // Collect from generic parameters
                for param in &model.generic_params {
                    used_params.insert(param.clone());
                }
                
                // Collect from field type annotations
                for field in model.fields.values() {
                    self.extract_type_vars_from_annotation(&field.type_annotation, used_params);
                }
            }
            PySemanticType::DiscriminatedUnion(union) => {
                // Recursively scan variant types
                for variant_type in union.variants.values() {
                    self.collect_type_vars_from_semantic_type(variant_type, used_params);
                }
            }
            PySemanticType::RootModelWrapper(wrapper) => {
                // Extract from union type annotation
                self.extract_type_vars_from_annotation(&wrapper.union_type, used_params);
            }
            PySemanticType::FactoryPattern(factory) => {
                // Extract from static method signatures
                for method in &factory.static_methods {
                    self.extract_type_vars_from_annotation(&method.return_type, used_params);
                    for param in &method.parameters {
                        self.extract_type_vars_from_annotation(&param.type_annotation, used_params);
                    }
                }
            }
            _ => {
                // Other semantic types don't typically contain type parameters
            }
        }
    }

    /// Extract potential TypeVar names from type annotation strings
    fn extract_type_vars_from_annotation(&self, annotation: &str, used_params: &mut std::collections::HashSet<String>) {
        // Look for Generic[...] patterns
        if let Some(start) = annotation.find("Generic[") {
            let end_bracket = annotation[start..].find(']').unwrap_or(annotation.len() - start);
            let generic_content = &annotation[start + 8..start + end_bracket];
            
            // Split by comma and extract each type parameter
            for param in generic_content.split(',') {
                let param = param.trim();
                if self.is_likely_type_parameter(param) {
                    used_params.insert(self.sanitize_type_var_name(param));
                }
            }
        }
        
        // Look for bare type parameter names in the annotation
        // Split on various delimiters and check each token
        let delimiters = ['[', ']', ',', '(', ')', '<', '>', ' ', '\t', '\n'];
        let mut current_token = String::new();
        
        for ch in annotation.chars() {
            if delimiters.contains(&ch) {
                if !current_token.is_empty() {
                    let clean_token = current_token.trim();
                    if self.is_likely_type_parameter(clean_token) {
                        used_params.insert(self.sanitize_type_var_name(clean_token));
                    }
                    current_token.clear();
                }
            } else {
                current_token.push(ch);
            }
        }
        
        // Handle the last token
        if !current_token.is_empty() {
            let clean_token = current_token.trim();
            if self.is_likely_type_parameter(clean_token) {
                used_params.insert(self.sanitize_type_var_name(clean_token));
            }
        }
    }


    /// Sanitize TypeVar name to be a valid Python identifier
    fn sanitize_type_var_name(&self, name: &str) -> String {
        if name.chars().next().map_or(false, |c| c.is_ascii_digit()) {
            format!("T{}", name)
        } else {
            name.to_string()
        }
    }

    /// Determine if a name is likely a type parameter
    fn is_likely_type_parameter(&self, name: &str) -> bool {
        // Type parameters are usually:
        // 1. Single uppercase letters (T, K, V, etc.)
        // 2. Short uppercase names (ID, MPN, etc.) 
        // 3. Common patterns like Data, Entity, etc.
        
        if name.len() == 1 && name.chars().all(|c| c.is_uppercase()) {
            return true;
        }
        
        // Common type parameter patterns - expanded list
        let common_patterns = [
            "ID", "MPN", "Data", "Entity", "T", "K", "V", "U", "R", "E",
            "Input", "Output", "Result", "Response", "Request", "D", "I", "O",
            "F", "G", "H", "J", "L", "M", "N", "P", "Q", "S", "W", "X", "Y", "Z"
        ];
        
        if common_patterns.contains(&name) {
            return true;
        }
        
        // Short all-caps names are likely type parameters (2-4 chars, all uppercase/digits)
        if name.len() >= 2 && name.len() <= 4 && name.chars().all(|c| c.is_uppercase() || c.is_ascii_digit()) {
            return true;
        }
        
        // Common patterns: CamelCase with all caps (EntityID, DataType, etc.)
        if name.len() <= 8 && name.chars().all(|c| c.is_uppercase() || c.is_ascii_digit()) {
            return true;
        }
        
        false
    }

    /// Parse a type annotation string into a proper TypeExpr
    fn parse_type_annotation(&self, type_str: &str) -> TypeExpr {        
        // Handle common patterns first
        if type_str.starts_with("Union[") && type_str.ends_with(']') {
            // Parse Union[...] types
            self.parse_union_type(type_str)
        } else if type_str.starts_with("Optional[") && type_str.ends_with(']') {
            // Parse Optional[...] types
            let inner = &type_str[9..type_str.len()-1];
            TypeExpr::optional(self.parse_type_annotation(inner))
        } else if type_str.starts_with("list[") && type_str.ends_with(']') {
            // Parse list[...] types
            let inner = &type_str[5..type_str.len()-1];
            TypeExpr::generic("list", vec![self.parse_type_annotation(inner)])
        } else if type_str.starts_with("dict[") && type_str.ends_with(']') {
            // Parse dict[K, V] types
            let inner = &type_str[5..type_str.len()-1];
            let args = self.parse_type_args(inner);
            TypeExpr::generic("dict", args)
        } else if type_str.starts_with("ReflectapiOption[") && type_str.ends_with(']') {
            // Parse ReflectapiOption[...] types
            let inner = &type_str[17..type_str.len()-1]; // Remove "ReflectapiOption[" and "]"
            TypeExpr::generic("ReflectapiOption", vec![self.parse_type_annotation(inner)])
        } else if type_str.contains("Literal[") {
            // Parse Literal["value"] types - careful handling needed
            self.parse_literal_type(type_str)
        } else {
            // Simple type - apply TypeVar sanitization if it's a type parameter
            if self.is_likely_type_parameter(type_str) {
                TypeExpr::name(&self.sanitize_type_var_name(type_str))
            } else {
                TypeExpr::name(type_str)
            }
        }
    }

    fn parse_union_type(&self, type_str: &str) -> TypeExpr {
        // Extract Union[...] content
        let content = &type_str[6..type_str.len()-1]; // Remove "Union[" and "]"
        let args = self.parse_type_args(content);
        TypeExpr::union(args)
    }

    fn parse_literal_type(&self, type_str: &str) -> TypeExpr {
        // Parse Literal["value"] types properly
        if type_str.starts_with("Literal[") && type_str.ends_with(']') {
            let content = &type_str[8..type_str.len()-1]; // Remove "Literal[" and "]"
            // Handle quoted string literals
            if content.starts_with('"') && content.ends_with('"') {
                let literal_value = &content[1..content.len()-1]; // Remove quotes
                TypeExpr::Literal(crate::codegen::python::syntax::LiteralValue::String(literal_value.to_string()))
            } else {
                // Handle other literal types (numbers, etc.)
                TypeExpr::name(type_str)
            }
        } else {
            // Not a proper literal, treat as name
            TypeExpr::name(type_str)
        }
    }

    fn parse_type_args(&self, args_str: &str) -> Vec<TypeExpr> {
        // Simple comma-splitting for now - doesn't handle nested brackets perfectly
        // but good enough for most cases
        let mut args = Vec::new();
        let mut bracket_depth = 0;
        let mut current_arg = String::new();

        for ch in args_str.chars() {
            match ch {
                '[' => {
                    bracket_depth += 1;
                    current_arg.push(ch);
                }
                ']' => {
                    bracket_depth -= 1;
                    current_arg.push(ch);
                }
                ',' if bracket_depth == 0 => {
                    if !current_arg.trim().is_empty() {
                        args.push(self.parse_type_annotation(current_arg.trim()));
                        current_arg.clear();
                    }
                }
                _ => {
                    current_arg.push(ch);
                }
            }
        }

        // Add the last argument
        if !current_arg.trim().is_empty() {
            args.push(self.parse_type_annotation(current_arg.trim()));
        }

        args
    }
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

/// Sanitize class names to be valid Python identifiers
// Sanitization functions removed - all naming decisions are made in the semantic layer
// using the centralized naming module (naming.rs)

/// Clean description text for use in docstrings
fn clean_description_for_docstring(description: &str) -> String {
    let cleaned = description
        .replace("\\n", " ")    // Convert literal \n to spaces
        .replace("\n", " ")     // Convert actual newlines to spaces
        .replace("\\r", " ")    // Convert literal \r to spaces
        .replace("\r", " ")     // Convert actual carriage returns to spaces
        .replace("\\t", " ")    // Convert literal \t to spaces
        .replace("\t", " ")     // Convert actual tabs to spaces
        .replace("\\", "")      // Remove remaining backslashes
        .chars()
        .filter(|&c| c != '\x00' && c.is_ascii())  // Remove null chars and non-ASCII
        .collect::<String>()
        .trim()
        .to_string();
    
    // Return empty string if only whitespace or quotes remain
    if cleaned.is_empty() || cleaned.chars().all(|c| c.is_whitespace() || c == '"' || c == '\'') {
        String::new()
    } else {
        cleaned
    }
}

impl Default for PySyntaxTransform {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::python::semantic::{PyCodegenConfig, PySemanticIR, RequiredImports};
    use std::collections::BTreeMap;

    #[test]
    fn test_simple_transform() {
        let semantic = PySemanticIR {
            package_name: "test_package".to_string(),
            description: "Test package".to_string(),
            types: Vec::new(),
            endpoints: BTreeMap::new(),
            required_imports: RequiredImports::default(),
            config: PyCodegenConfig::default(),
        };

        let transform = PySyntaxTransform::new();
        let module = transform.transform(semantic);

        assert_eq!(module.name, "test_package");
        // Docstrings temporarily disabled due to literal \n issue
        // assert!(module.docstring.is_some());
        assert!(!module.future_imports.is_empty());
    }

    #[test]
    fn test_capitalize_first() {
        assert_eq!(capitalize_first("hello"), "Hello");
        assert_eq!(capitalize_first(""), "");
        assert_eq!(capitalize_first("a"), "A");
    }
}
