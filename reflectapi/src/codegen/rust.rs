use std::collections::HashMap;

use anyhow::Context;
use askama::Template;
use indexmap::IndexMap;
use reflectapi_schema::Function;

pub fn generate(mut schema: crate::Schema) -> anyhow::Result<String> {
    let implemented_types = __build_implemented_types();

    let mut rendered_types = HashMap::new();
    for original_type_name in schema.consolidate_types() {
        if original_type_name.starts_with("std::") || original_type_name.starts_with("reflectapi::")
        {
            continue;
        }
        let type_def = schema.get_type(&original_type_name).context(format!(
            "internal error: failed to get consolidated type definition for type: {}",
            original_type_name
        ))?;
        if implemented_types.contains_key(&original_type_name) {
            continue;
        }
        if type_def.as_primitive().map(|i| &i.fallback).is_some() {
            continue;
        }
        rendered_types.insert(
            original_type_name,
            render_type(type_def, &schema, &implemented_types)?,
        );
    }

    let functions_by_name = schema
        .functions()
        .map(|f| (f.name.clone(), f))
        .collect::<IndexMap<_, _>>();
    let function_groups = function_groups_from_function_names(
        schema
            .functions()
            .map(|f| f.name.clone())
            .collect::<Vec<_>>(),
    );

    let mut generated_code = vec![];

    let file_template = templates::FileHeader {
        name: schema.name.clone(),
        description: schema.description.clone(),
    };
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let module = modules_from_function_group(
        "__definition".into(),
        &function_groups,
        &schema,
        &implemented_types,
        &functions_by_name,
    );
    generated_code.push(module.render().context("Failed to render template")?);

    let file_template = templates::FileMiddle {};
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let module = modules_from_rendered_types(schema.consolidate_types(), rendered_types);
    generated_code.push(
        module
            .render()
            .context("Failed to render template")?
            .trim()
            .to_string(),
    );

    let mut rendered_functions = Vec::new();
    for function in schema.functions.iter() {
        rendered_functions.push(render_function(function, &schema, &implemented_types)?);
    }

    let generated_impl_client = client_impl_from_function_group(8, &function_groups).render();
    let file_template = templates::FileFootter {
        client_impl: "".into(), //generated_impl_client,
        implemented_functions: rendered_functions.join("\n"),
    };
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let generated_code = generated_code.join("\n");
    Ok(generated_code)
}

mod templates {
    use askama::Template;
    use indexmap::IndexMap; // bring trait in scope

    #[derive(Template)]
    #[template(
        source = "// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: {{ name }}
// {{ description }}
",
        ext = "txt"
    )]
    pub(super) struct FileHeader {
        pub name: String,
        pub description: String,
    }

    #[derive(Template)]
    #[template(
        source = "
pub trait Client<E> {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), E>;
}

pub enum Error<AE, NE> {
    Application(AE),
    Network(NE),
    Protocol {
        info: String,
        stage: ProtocolErrorStage,
    },
    Server(http::StatusCode, bytes::Bytes),
}

pub enum ProtocolErrorStage {
    SerializeRequestBody,
    SerializeRequestHeaders,
    DeserializeResponseBody(bytes::Bytes),
    DeserializeResponseError(http::StatusCode, bytes::Bytes),
}

#[cfg(feature = \"reqwest\")]
pub struct ReqwestClient {
    client: reqwest::Client,
    base_url: String,
}

#[cfg(feature = \"reqwest\")]
impl ReqwestClient {
    pub fn new(client: reqwest::Client, base_url: String) -> Self {
        Self { client, base_url }
    }
}

#[cfg(feature = \"reqwest\")]
impl Client<reqwest::Error> for ReqwestClient {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), reqwest::Error> {
        let url = format!(\"{}{}\", self.base_url, path);
        let mut request = self.client.post(&url);
        for (k, v) in headers {
            request = request.header(k, v);
        }
        let response = request.body(body).send().await;
        let response = match response {
            Ok(response) => response,
            Err(e) => return Err(e),
        };
        let status = response.status();
        let body = response.bytes().await;
        let body = match body {
            Ok(body) => body,
            Err(e) => return Err(e),
        };
        Ok((status, body))
    }
}
",
        ext = "txt"
    )]
    pub(super) struct FileMiddle {}

    #[derive(Template)]
    #[template(
        source = "
mod __implementation {
    async fn __request_impl<C, NE, I, H, O, E>(
        client: &C,
        path: &str,
        body: I,
        headers: H,
    ) -> Result<O, Error<E, NE>>
    where
        C: Client<NE>,
        I: serde::Serialize,
        H: serde::Serialize,
        O: serde::de::DeserializeOwned,
        E: serde::de::DeserializeOwned,
    {
        let body = serde_json::to_vec(&body).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::SerializeRequestBody,
        })?;
        let body = bytes::Bytes::from(body);
        let headers = serde_json::to_value(&headers).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::SerializeRequestHeaders,
        })?;

        let mut headers_serialized = HashMap::new();
        match headers {
            serde_json::Value::Object(headers) => {
                for (k, v) in headers.into_iter() {
                    let v_str = match v {
                        serde_json::Value::String(v) => v,
                        v => v.to_string(),
                    };
                    headers_serialized.insert(k, v_str);
                }
            }
            _ => {
                return Err(Error::Protocol {
                    info: \"Headers must be an object\".to_string(),
                    stage: ProtocolErrorStage::SerializeRequestHeaders,
                });
            }
        }
        let (status, body) = client
            .request(path, body, headers_serialized)
            .await
            .map_err(Error::Network)?;
        if status.is_success() {
            let output = serde_json::from_slice(&body).map_err(|e| Error::Protocol {
                info: e.to_string(),
                stage: ProtocolErrorStage::DeserializeResponseBody(body),
            })?;
            Ok(output)
        } else if status.is_client_error() {
            match serde_json::from_slice::<E>(&body) {
                Ok(error) => Err(Error::Application(error)),
                Err(e) => Err(Error::Protocol {
                    info: e.to_string(),
                    stage: ProtocolErrorStage::DeserializeResponseError(status, body),
                }),
            }
        } else {
            Err(Error::Server(status, body))
        }
    }
}

{{ implemented_functions }}
",
        ext = "txt"
    )]
    pub(super) struct FileFootter {
        pub client_impl: String,
        pub implemented_functions: String,
    }

    #[derive(Template)]
    #[template(
        source = "
{{ self.render_start() }}
{%- for type in types.iter() %}
{{ type }}
{%- endfor %}
{%- for module in self.submodules_sorted() %}
{{ module }}
{%- endfor %}

{{ self.render_end() }}",
        ext = "txt"
    )]
    pub(super) struct Module {
        pub name: String,
        pub types: Vec<String>,
        pub submodules: IndexMap<String, Module>,
    }

    impl Module {
        fn submodules_sorted(&self) -> Vec<&Module> {
            let mut submodules = self.submodules.values().collect::<Vec<_>>();
            submodules.sort_by(|a, b| a.name.cmp(&b.name));
            submodules
        }

        fn is_empty(&self) -> bool {
            self.types.is_empty() && self.submodules.iter().all(|(_, m)| m.is_empty())
        }

        fn render_start(&self) -> String {
            if self.name.is_empty() || self.is_empty() {
                "".into()
            } else {
                format!("mod {} {{", self.name)
            }
        }

        fn render_end(&self) -> String {
            if self.name.is_empty() || self.is_empty() {
                "".into()
            } else {
                "}".into()
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}pub {{ self.render_keyword() }} {{ name }} {{ self.render_brackets().0 }}
    {%- for field in fields.iter() %}
    {{ field }},
    {%- endfor %}
{{ self.render_brackets().1 }}{{ self.render_flattened_types() }}",
        ext = "txt"
    )]
    pub(super) struct Struct {
        pub name: String,
        pub description: String,
        pub fields: Vec<Field>,
        pub is_tuple: bool,
        pub flattened_types: Vec<String>,
    }

    impl Struct {
        fn render_keyword(&self) -> String {
            if self.is_tuple || !self.flattened_types.is_empty() {
                "type".into()
            } else {
                "struct".into()
            }
        }

        fn render_brackets(&self) -> (&'static str, &'static str) {
            if !self.flattened_types.is_empty() {
                ("= {", "}")
            } else if self.is_tuple {
                ("= [", "]\n")
            } else {
                ("{", "}")
            }
        }

        fn render_flattened_types(&self) -> String {
            if self.flattened_types.is_empty() {
                "".into()
            } else {
                return format!(" & {}", self.flattened_types.join(" &\n    "));
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}pub type {{ name }} =
    {%- for variant in variants.iter() %}
    {{ variant }}
    {%- endfor %};",
        ext = "txt"
    )]
    pub(super) struct Enum {
        pub name: String,
        pub description: String,
        pub variants: Vec<Variant>,
    }

    #[derive(Template)]
    #[template(source = "{{ description }}| {{ self.render_self()? }}", ext = "txt")]
    pub(super) struct Variant {
        pub name: String,
        pub description: String,
        pub representation: crate::Representation,
        pub fields: Vec<Field>,
        pub discriminant: Option<isize>,
        pub untagged: bool,
    }

    impl Variant {
        fn fields_brakets(&self) -> (String, String) {
            if self.fields.is_empty() {
                ("".into(), "".into())
            } else if self.fields.iter().all(|f| f.is_unnamed()) {
                if self.fields.len() == 1 {
                    ("".into(), "".into())
                } else {
                    ("[".into(), "]".into())
                }
            } else {
                ("{".into(), "}".into())
            }
        }

        fn render_self(&self) -> anyhow::Result<String> {
            if self.fields.is_empty() {
                if let Some(discriminant) = self.discriminant {
                    return Ok(format!("{} /* {} */", discriminant, self.name));
                }
                return Ok(format!("\"{}\"", self.normalized_name()));
            }
            if self.untagged {
                return self.render_fields(None);
            }
            let r = match &self.representation {
                crate::Representation::External => {
                    format!(
                        "{{\n        {}: {}\n    }}",
                        self.normalized_name(),
                        self.render_fields(None)?
                    )
                }
                crate::Representation::Internal { tag } => self.render_fields(Some(tag))?,
                crate::Representation::Adjacent { tag, content } => {
                    format!(
                        "{{ {}: {}, {}: {} }}",
                        tag,
                        self.normalized_name(),
                        content,
                        self.render_fields(None)?
                    )
                }
                crate::Representation::None => self.render_fields(None)?,
            };
            Ok(r)
        }

        fn normalized_name(&self) -> String {
            if self.name.chars().enumerate().any(|(ind, c)| {
                ind == 0 && !c.is_alphabetic() && c != '_' || !c.is_alphanumeric() && c != '_'
            }) {
                format!("\"{}\"", self.name)
            } else {
                self.name.clone()
            }
        }

        fn render_fields(&self, inner_tag: Option<&str>) -> anyhow::Result<String> {
            let brackets = self.fields_brakets();
            let mut rendered_fields = Vec::new();
            if let Some(inner_tag) = inner_tag {
                rendered_fields.push(format!("{}: \"{}\"", inner_tag, self.name));
            }
            for field in self.fields.iter() {
                rendered_fields.push(field.render()?);
            }
            Ok(format!(
                "{}\n            {}\n        {}",
                brackets.0,
                rendered_fields.join(",\n            "),
                brackets.1
            ))
        }
    }

    #[derive(Template)]
    #[template(
        source = "{{ description }}{{ self.serde_attributes() }}{% if !self.is_unnamed() %}{{ self.normalized_name() }}: {{ type_ }}{% else %}{{ type_ }}{% endif  %}",
        ext = "txt"
    )]
    pub(super) struct Field {
        pub name: String,
        pub serde_name: String,
        pub description: String,
        pub type_: String,
        pub optional: bool,
    }

    impl Field {
        fn is_unnamed(&self) -> bool {
            self.name.parse::<u64>().is_ok()
        }

        fn normalized_name(&self) -> String {
            if self.name.chars().enumerate().any(|(ind, c)| {
                ind == 0 && !c.is_alphabetic() && c != '_' || !c.is_alphanumeric() && c != '_'
            }) {
                format!("\"{}\"", self.name)
            } else {
                self.name.clone()
            }
        }

        fn serde_attributes(&self) -> String {
            let mut attrs = vec![];
            if self.serde_name != self.name {
                attrs.push(format!("rename = \"{}\"", self.serde_name));
            }
            if self.optional {
                attrs.push("default".into());

                // this one is important to not serialize undefined values
                // as this is the special built-in type which allows to differentiate between undefined and null
                if self.type_.starts_with("reflectapi::Option<") {
                    attrs.push("skip_serializing_if = \"reflectapi::Option::is_undefined\"".into());
                }
                // the rest are nice to have, we enumerate only commonly used std types
                if self.type_.starts_with("std::option::Option<") {
                    attrs.push("skip_serializing_if = \"std::option::Option::is_none\"".into());
                }
                if self.type_.starts_with("std::vec::Vec<") {
                    attrs.push("skip_serializing_if = \"std::vec::Vec::is_empty\"".into());
                }
                if self.type_.starts_with("std::collections::") {
                    let type_without_generics = self.type_.split('<').next().unwrap();
                    attrs.push(format!(
                        "skip_serializing_if = \"{}::is_empty\"",
                        type_without_generics
                    ));
                }
            }
            if attrs.is_empty() {
                "".into()
            } else {
                format!("#[serde({})]\n    ", attrs.join(", "))
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}pub type {{ name }} = {{ type_ }};",
        ext = "txt"
    )]
    pub(super) struct __Alias {
        pub name: String,
        pub description: String,
        pub type_: String,
    }

    #[derive(Template)]
    #[template(
        source = "async fn {{ name }}(&self, input: {{ input_type }}, headers: {{ input_headers }})
        -> Result<{{ output_type }}, super::Error<{{ error_type }}, E>> {
            __request_impl(&self.client, \"{{ path }}\", input, headers).await
}",
        ext = "txt"
    )]
    pub(super) struct FunctionImplementationTemplate {
        pub name: String,
        pub path: String,
        pub input_type: String,
        pub input_headers: String,
        pub output_type: String,
        pub error_type: String,
    }

    pub(super) struct ClientImplementationGroup {
        pub offset: usize,
        pub functions: IndexMap<String, String>,
        pub subgroups: IndexMap<String, ClientImplementationGroup>,
    }

    impl ClientImplementationGroup {
        fn offset(&self) -> String {
            " ".repeat(self.offset)
        }
        pub fn render(&self) -> String {
            let mut result = vec![];
            result.push(format!("{{"));
            for (name, function) in self.functions.iter() {
                result.push(format!(
                    "{}{}: {}(client_instance),",
                    self.offset(),
                    name,
                    function
                ));
            }
            for (name, group) in self.subgroups.iter() {
                result.push(format!("{}{}: {}", self.offset(), name, group.render()));
            }
            result.push(format!("{}}},", " ".repeat(self.offset - 4)));
            result.join("\n")
        }
    }
}

struct FunctionGroup {
    functions: Vec<String>,
    subgroups: IndexMap<String, FunctionGroup>,
}

fn function_groups_from_function_names(function_names: Vec<String>) -> FunctionGroup {
    let mut root_group = FunctionGroup {
        functions: vec![],
        subgroups: IndexMap::new(),
    };
    for function_name in function_names {
        let mut group = &mut root_group;
        let mut parts = function_name.split(".").collect::<Vec<_>>();
        parts.pop().unwrap();
        for part in parts {
            group = group.subgroups.entry(part.into()).or_insert(FunctionGroup {
                functions: vec![],
                subgroups: IndexMap::new(),
            });
        }
        group.functions.push(function_name);
    }
    root_group
}

fn client_impl_from_function_group(
    offset: usize,
    group: &FunctionGroup,
) -> templates::ClientImplementationGroup {
    templates::ClientImplementationGroup {
        offset: offset,
        functions: group
            .functions
            .iter()
            .map(|f| {
                (
                    f.split('.').last().unwrap().replace("-", "_"),
                    f.replace('.', "__").replace("-", "_"),
                )
            })
            .collect(),
        subgroups: group
            .subgroups
            .iter()
            .map(|(n, g)| (n.clone(), client_impl_from_function_group(offset + 4, g)))
            .collect(),
    }
}

fn __function_signature(
    function: &Function,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> (String, String, String, String) {
    let input_type = if let Some(input_type) = function.input_type.as_ref() {
        __type_ref_to_ts_ref(input_type, schema, implemented_types)
    } else {
        "{}".into()
    };
    let input_headers = if let Some(input_headers) = function.input_headers.as_ref() {
        __type_ref_to_ts_ref(input_headers, schema, implemented_types)
    } else {
        "{}".into()
    };
    let output_type = if let Some(output_type) = function.output_type.as_ref() {
        __type_ref_to_ts_ref(output_type, schema, implemented_types)
    } else {
        "{}".into()
    };
    let error_type = if let Some(error_type) = function.error_type.as_ref() {
        __type_ref_to_ts_ref(error_type, schema, implemented_types)
    } else {
        "{}".into()
    };
    (input_type, input_headers, output_type, error_type)
}

fn modules_from_function_group(
    name: String,
    group: &FunctionGroup,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
    functions_by_name: &IndexMap<String, &Function>,
) -> templates::Module {
    let mut module = templates::Module {
        name: name,
        types: vec![],
        submodules: IndexMap::new(),
    };
    let mut type_template = templates::Struct {
        name: "Interface".into(),
        description: "".into(),
        fields: Default::default(),
        is_tuple: false,
        flattened_types: vec![],
    };

    for function_name in group.functions.iter() {
        let function = functions_by_name.get(function_name).unwrap();
        let (input_type, input_headers, output_type, error_type) =
            __function_signature(function, schema, implemented_types);
        type_template.fields.push(templates::Field {
            name: function_name.split('.').last().unwrap().replace("-", "_"),
            serde_name: String::new(),
            description: __doc_to_ts_comments(function.description.as_str(), 4),
            type_: format!(
                "(input: {}, headers: {})\n        => Result<{}, {}>",
                input_type, input_headers, output_type, error_type
            ),
            optional: false,
        });
    }

    type_template
        .fields
        .extend(group.subgroups.keys().map(|f| templates::Field {
            name: f.clone(),
            serde_name: String::new(),
            description: "".into(),
            type_: format!("{}.Interface", f),
            optional: false,
        }));

    module.types.push(type_template.render().unwrap());

    for (subgroup_name, subgroup) in group.subgroups.iter() {
        module.submodules.insert(
            subgroup_name.clone(),
            modules_from_function_group(
                subgroup_name.clone(),
                subgroup,
                schema,
                implemented_types,
                functions_by_name,
            ),
        );
    }
    module
}

fn modules_from_rendered_types(
    original_type_names: Vec<String>,
    mut rendered_types: HashMap<String, String>,
) -> templates::Module {
    let mut root_module = templates::Module {
        name: "".into(),
        types: vec![],
        submodules: IndexMap::new(),
    };

    for original_type_name in original_type_names {
        let mut module = &mut root_module;
        let mut parts = original_type_name.split("::").collect::<Vec<_>>();
        parts.pop().unwrap();
        for part in parts {
            module = module
                .submodules
                .entry(part.into())
                .or_insert(templates::Module {
                    name: part.into(),
                    types: vec![],
                    submodules: IndexMap::new(),
                });
        }
        if let Some(rendered_type) = rendered_types.remove(&original_type_name) {
            module.types.push(rendered_type);
        }
    }

    root_module
}

fn render_function(
    function: &Function,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Result<String, anyhow::Error> {
    let (input_type, input_headers, output_type, error_type) =
        __function_signature(function, schema, implemented_types);
    let function_template = templates::FunctionImplementationTemplate {
        name: function.name.replace("-", "_").replace('.', "__"),
        path: format!("{}/{}", function.path, function.name),
        input_type,
        input_headers,
        output_type,
        error_type,
    };
    function_template
        .render()
        .context("Failed to render template")
}

fn render_type(
    type_def: &crate::Type,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Result<String, anyhow::Error> {
    let type_name = __type_to_ts_name(&type_def);

    Ok(match type_def {
        crate::Type::Struct(struct_def) => {
            if struct_def.is_alias() {
                let field_type_ref = struct_def.fields.first().unwrap().type_ref.clone();
                let alias_template = templates::__Alias {
                    name: type_name,
                    description: __doc_to_ts_comments(&struct_def.description, 0),
                    type_: __type_ref_to_ts_ref(&field_type_ref, schema, implemented_types),
                };
                alias_template
                    .render()
                    .context("Failed to render template")?
            } else {
                let interface_template = templates::Struct {
                    name: type_name,
                    description: __doc_to_ts_comments(&struct_def.description, 0),
                    is_tuple: struct_def.is_tuple(),
                    fields: struct_def
                        .fields
                        .iter()
                        .filter(|f| !f.flattened)
                        .map(|field| templates::Field {
                            name: field.name().into(),
                            serde_name: field.serde_name().into(),
                            description: __doc_to_ts_comments(&field.description, 4),
                            type_: __type_ref_to_ts_ref(&field.type_ref, schema, implemented_types),
                            optional: !field.required,
                        })
                        .collect::<Vec<_>>(),
                    flattened_types: struct_def
                        .fields
                        .iter()
                        .filter(|f| f.flattened)
                        .map(|field| {
                            let type_ref =
                                __type_ref_to_ts_ref(&field.type_ref, schema, implemented_types);
                            if field.required {
                                type_ref
                            } else {
                                format!("Partial<{}>", type_ref.replace(" | null", ""))
                            }
                        })
                        .collect::<Vec<_>>(),
                };
                interface_template
                    .render()
                    .context("Failed to render template")?
            }
        }
        crate::Type::Enum(enum_def) => {
            let enum_template = templates::Enum {
                name: type_name,
                description: __doc_to_ts_comments(&enum_def.description, 0),
                variants: enum_def
                    .variants
                    .iter()
                    .map(|variant| templates::Variant {
                        name: variant.serde_name().into(),
                        description: __doc_to_ts_comments(&variant.description, 4),
                        representation: enum_def.representation.clone(),
                        fields: variant
                            .fields
                            .iter()
                            .map(|field| templates::Field {
                                name: field.name().into(),
                                serde_name: field.serde_name().into(),
                                description: __doc_to_ts_comments(&field.description, 12),
                                type_: __type_ref_to_ts_ref(
                                    &field.type_ref,
                                    schema,
                                    implemented_types,
                                ),
                                optional: !field.required,
                            })
                            .collect::<Vec<_>>(),
                        discriminant: variant.discriminant,
                        untagged: variant.untagged,
                    })
                    .collect::<Vec<_>>(),
            };
            enum_template
                .render()
                .context("Failed to render template")?
        }
        crate::Type::Primitive(type_def) => {
            eprintln!(
                "warning: {} type is not implemented for Typescript",
                type_def.name
            );
            let alias_template = templates::__Alias {
                name: type_name,
                description: __doc_to_ts_comments(&type_def.description, 0),
                type_: format!(
                    "any /* fallback to any for unimplemented type: {} */",
                    type_def.name
                ),
            };
            alias_template
                .render()
                .context("Failed to render template")?
        }
    })
}

fn __type_ref_to_ts_ref(
    type_ref: &crate::TypeReference,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> String {
    if let Some(resolved_type) = __resolve_type_ref(type_ref, schema, implemented_types) {
        return resolved_type;
    }

    format!(
        "{}{}",
        type_ref.name,
        __type_ref_params_to_ts_ref(&type_ref.parameters, schema, implemented_types)
    )
}

fn __type_ref_params_to_ts_ref(
    type_params: &Vec<crate::TypeReference>,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> String {
    let p = type_params
        .iter()
        .map(|type_ref| __type_ref_to_ts_ref(type_ref, schema, implemented_types))
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn __type_to_ts_name(type_def: &crate::Type) -> String {
    let n = type_def
        .name()
        .split("::")
        .last()
        .unwrap_or_default()
        .to_string();
    let p = __type_params_to_ts_name(type_def.parameters());
    format!("{}{}", n, p)
}

fn __type_params_to_ts_name(type_params: std::slice::Iter<'_, crate::TypeParameter>) -> String {
    let p = type_params
        .map(|type_param| type_param.name.clone())
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn __resolve_type_ref(
    type_ref: &crate::TypeReference,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Option<String> {
    let Some(mut implementation) = implemented_types.get(type_ref.name.as_str()).cloned() else {
        return None;
    };

    let Some(type_def) = schema.get_type(type_ref.name()) else {
        return None;
    };

    for (type_def_param, type_ref_param) in type_def.parameters().zip(type_ref.parameters.iter()) {
        if implementation.contains(type_def_param.name.as_str()) {
            implementation = implementation.replace(
                type_def_param.name.as_str(),
                __type_ref_to_ts_ref(type_ref_param, schema, implemented_types).as_str(),
            );
        }
    }

    Some(implementation)
}

fn __doc_to_ts_comments(doc: &str, offset: u8) -> String {
    if doc.is_empty() {
        return "".into();
    }

    let offset = " ".repeat(offset as usize);
    let doc = doc.split("\n").collect::<Vec<_>>();
    let sp = if doc.iter().all(|i| i.starts_with(" ")) {
        ""
    } else {
        " "
    };
    let doc = doc
        .iter()
        .map(|line| format!("///{}{}", sp, line.trim_end()))
        .collect::<Vec<_>>()
        .join(format!("\n{}", offset).as_str());
    format!("{}\n{}", doc, offset)
}

fn __build_implemented_types() -> HashMap<String, String> {
    let mut implemented_types = HashMap::new();

    // warning: all generic type parameter names should match reflect defnition coming from
    // the implementation of reflect for standard types

    implemented_types.insert("std::tuple::Tuple1".into(), "(T1)".into());
    implemented_types.insert("std::tuple::Tuple2".into(), "(T1, T2)".into());
    implemented_types.insert("std::tuple::Tuple3".into(), "(T1, T2, T3)".into());
    implemented_types.insert("std::tuple::Tuple4".into(), "(T1, T2, T3, T4)".into());
    implemented_types.insert("std::tuple::Tuple5".into(), "(T1, T2, T3, T4, T5)".into());
    implemented_types.insert(
        "std::tuple::Tuple6".into(),
        "(T1, T2, T3, T4, T5, T6)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple7".into(),
        "(T1, T2, T3, T4, T5, T6, T7)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple8".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple9".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple10".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple11".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple12".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)".into(),
    );

    implemented_types
}
