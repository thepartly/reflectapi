use std::collections::HashMap;

use anyhow::Context;
use askama::Template;
use indexmap::IndexMap;
use reflectapi_schema::Function;

pub fn generate(mut schema: crate::Schema) -> anyhow::Result<String> {
    let implemented_types = __build_implemented_types();

    let mut rendered_types = HashMap::new();
    for original_type_name in schema.consolidate_types() {
        if original_type_name.starts_with("std::") || original_type_name.starts_with("reflectapi::")
        {
            continue;
        }
        let type_def = schema.get_type(&original_type_name).context(format!(
            "internal error: failed to get consolidated type definition for type: {}",
            original_type_name
        ))?;
        if implemented_types.contains_key(&original_type_name) {
            continue;
        }
        if type_def.as_primitive().map(|i| &i.fallback).is_some() {
            continue;
        }
        rendered_types.insert(
            original_type_name,
            __render_type(type_def, &schema, &implemented_types)?,
        );
    }

    let functions_by_name = schema
        .functions()
        .map(|f| (f.name.clone(), f))
        .collect::<IndexMap<_, _>>();
    let function_groups = __function_groups_from_function_names(
        schema
            .functions()
            .map(|f| f.name.clone())
            .collect::<Vec<_>>(),
    );

    let mut generated_code = vec![];

    let file_template = templates::__FileHeader {
        name: schema.name.clone(),
        description: schema.description.clone(),
    };
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let module = modules_from_function_group(
        "__definition".into(),
        &function_groups,
        &schema,
        &implemented_types,
        &functions_by_name,
    );
    generated_code.push(module.render().context("Failed to render template")?);

    let file_template = templates::__FileMiddle {};
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let module = __modules_from_rendered_types(schema.consolidate_types(), rendered_types);
    generated_code.push(
        module
            .render()
            .context("Failed to render template")?
            .trim()
            .to_string(),
    );

    let mut rendered_functions = Vec::new();
    for function in schema.functions.iter() {
        rendered_functions.push(__render_function(function, &schema, &implemented_types)?);
    }

    let generated_impl_client = client_impl_from_function_group(8, &function_groups).render();
    let file_template = templates::__FileFootter {
        implemented_functions: rendered_functions.join("\n"),
    };
    generated_code.push(
        file_template
            .render()
            .context("Failed to render template")?,
    );

    let generated_code = generated_code.join("\n");
    Ok(generated_code)
}

mod templates {
    use askama::Template;
    use indexmap::IndexMap; // bring trait in scope

    #[derive(Template)]
    #[template(
        source = "// DO NOT MODIFY THIS FILE MANUALLY
// This file was generated by reflectapi-cli
//
// Schema name: {{ name }}
// {{ description }}

// TODO make interface configurable via command line
pub use __definition::Interface;",
        ext = "txt"
    )]
    pub(super) struct __FileHeader {
        pub name: String,
        pub description: String,
    }

    #[derive(Template)]
    #[template(
        source = "
pub trait Client<E> {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), E>;
}

pub enum Error<AE, NE> {
    Application(AE),
    Network(NE),
    Protocol {
        info: String,
        stage: ProtocolErrorStage,
    },
    Server(http::StatusCode, bytes::Bytes),
}

pub enum ProtocolErrorStage {
    SerializeRequestBody,
    SerializeRequestHeaders,
    DeserializeResponseBody(bytes::Bytes),
    DeserializeResponseError(http::StatusCode, bytes::Bytes),
}

#[cfg(feature = \"reqwest\")]
impl Client<reqwest::Error> for reqwest::Client {
    async fn request(
        &self,
        path: &str,
        body: bytes::Bytes,
        headers: std::collections::HashMap<String, String>,
    ) -> Result<(http::StatusCode, bytes::Bytes), reqwest::Error> {
        let mut request = self.post(path);
        for (k, v) in headers {
            request = request.header(k, v);
        }
        let response = request.body(body).send().await;
        let response = match response {
            Ok(response) => response,
            Err(e) => return Err(e),
        };
        let status = response.status();
        let body = response.bytes().await;
        let body = match body {
            Ok(body) => body,
            Err(e) => return Err(e),
        };
        Ok((status, body))
    }
}
",
        ext = "txt"
    )]
    pub(super) struct __FileMiddle {}

    #[derive(Template)]
    #[template(
        source = "
async fn __request_impl<C, NE, I, H, O, E>(
    client: &C,
    path: &str,
    body: I,
    headers: H,
) -> Result<O, Error<E, NE>>
where
    C: Client<NE>,
    I: serde::Serialize,
    H: serde::Serialize,
    O: serde::de::DeserializeOwned,
    E: serde::de::DeserializeOwned,
{
    let body = serde_json::to_vec(&body).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestBody,
    })?;
    let body = bytes::Bytes::from(body);
    let headers = serde_json::to_value(&headers).map_err(|e| Error::Protocol {
        info: e.to_string(),
        stage: ProtocolErrorStage::SerializeRequestHeaders,
    })?;

    let mut headers_serialized = std::collections::HashMap::new();
    match headers {
        serde_json::Value::Object(headers) => {
            for (k, v) in headers.into_iter() {
                let v_str = match v {
                    serde_json::Value::String(v) => v,
                    v => v.to_string(),
                };
                headers_serialized.insert(k, v_str);
            }
        }
        _ => {
            return Err(Error::Protocol {
                info: \"Headers must be an object\".to_string(),
                stage: ProtocolErrorStage::SerializeRequestHeaders,
            });
        }
    }
    let (status, body) = client
        .request(path, body, headers_serialized)
        .await
        .map_err(Error::Network)?;
    if status.is_success() {
        let output = serde_json::from_slice(&body).map_err(|e| Error::Protocol {
            info: e.to_string(),
            stage: ProtocolErrorStage::DeserializeResponseBody(body),
        })?;
        Ok(output)
    } else if status.is_client_error() {
        match serde_json::from_slice::<E>(&body) {
            Ok(error) => Err(Error::Application(error)),
            Err(e) => Err(Error::Protocol {
                info: e.to_string(),
                stage: ProtocolErrorStage::DeserializeResponseError(status, body),
            }),
        }
    } else {
        Err(Error::Server(status, body))
    }
}


{{ implemented_functions }}
",
        ext = "txt"
    )]
    pub(super) struct __FileFootter {
        pub implemented_functions: String,
    }

    #[derive(Template)]
    #[template(
        source = "
{{ self.render_start() }}
{%- for type in types.iter() %}
{{ type }}
{%- endfor %}
{%- for module in self.submodules_sorted() %}
{{ module }}
{%- endfor %}

{{ self.render_end() }}",
        ext = "txt"
    )]
    pub(super) struct __Module {
        pub name: String,
        pub types: Vec<String>,
        pub submodules: IndexMap<String, __Module>,
    }

    impl __Module {
        fn submodules_sorted(&self) -> Vec<&__Module> {
            let mut submodules = self.submodules.values().collect::<Vec<_>>();
            submodules.sort_by(|a, b| a.name.cmp(&b.name));
            submodules
        }

        fn is_empty(&self) -> bool {
            self.types.is_empty() && self.submodules.iter().all(|(_, m)| m.is_empty())
        }

        fn render_start(&self) -> String {
            if self.name.is_empty() || self.is_empty() {
                "".into()
            } else {
                format!("mod {} {{", self.name)
            }
        }

        fn render_end(&self) -> String {
            if self.name.is_empty() || self.is_empty() {
                "".into()
            } else {
                "}".into()
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}#[derive(serde::Serialize, serde::Deserialize)]
pub struct {{ name }} {{ self.render_brackets().0 }}
    {%- for field in fields.iter() %}
    {{ field }},
    {%- endfor %}
{{ self.render_brackets().1 }}",
        ext = "txt"
    )]
    pub(super) struct __Struct {
        pub name: String,
        pub description: String,
        pub fields: Vec<__Field>,
        pub is_tuple: bool,
    }

    impl __Struct {
        fn render_brackets(&self) -> (&'static str, &'static str) {
            if self.is_tuple {
                ("(", ")")
            } else {
                ("{", "}")
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}#[derive(serde::Serialize, serde::Deserialize)]
{{ self.render_attributes() }}pub enum {{ name }} {
    {%- for variant in variants.iter() %}
    {{ variant }}
    {%- endfor %}
}",
        ext = "txt"
    )]
    pub(super) struct __Enum {
        pub name: String,
        pub description: String,
        pub variants: Vec<__Variant>,
        pub representation: crate::Representation,
    }

    impl __Enum {
        fn render_attributes(&self) -> String {
            match &self.representation {
                crate::Representation::External => "".into(),
                crate::Representation::Internal { tag } => {
                    format!("#[serde(tag = \"{}\")]\n", tag)
                }
                crate::Representation::Adjacent { tag, content } => {
                    format!("#[serde(tag = \"{}\", content = \"{}\")]\n", tag, content)
                }
                crate::Representation::None => {
                    format!("#[serde(untagged)]\n")
                }
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "{{ description }}{{ self.render_attributes() }}{{ self.render_self()? }},",
        ext = "txt"
    )]
    pub(super) struct __Variant {
        pub name: String,
        pub serde_name: String,
        pub description: String,
        pub fields: Vec<__Field>,
        pub discriminant: Option<isize>,
        pub untagged: bool,
    }

    impl __Variant {
        fn render_self(&self) -> anyhow::Result<String> {
            let brakets = self.render_brackets();
            let r = format!(
                "{}{}{}{}{}",
                self.name,
                brakets.0,
                self.render_fields()?,
                brakets.1,
                self.discriminant
                    .map(|d| format!(" = {}", d))
                    .unwrap_or_default()
            );
            Ok(r)
        }

        fn render_attributes(&self) -> String {
            let mut attrs = vec![];
            if self.serde_name != self.name {
                attrs.push(format!("rename = \"{}\"", self.serde_name));
            }
            if self.untagged {
                attrs.push("untagged".into());
            }
            if attrs.is_empty() {
                "".into()
            } else {
                format!("#[serde({})]\n    ", attrs.join(", "))
            }
        }

        fn render_fields(&self) -> anyhow::Result<String> {
            let mut rendered_fields = Vec::new();
            for field in self.fields.iter() {
                rendered_fields.push(field.render()?);
            }
            if rendered_fields.is_empty() {
                Ok("".into())
            } else {
                Ok(format!(
                    "\n        {},\n    ",
                    rendered_fields.join(",\n    ")
                ))
            }
        }

        fn render_brackets(&self) -> (&'static str, &'static str) {
            if self.fields.is_empty() {
                ("", "")
            } else if self.is_tuple() {
                ("(", ")")
            } else {
                (" {", "}")
            }
        }

        fn is_tuple(&self) -> bool {
            self.fields.iter().all(|f| f.is_unnamed())
        }
    }

    #[derive(Template)]
    #[template(
        source = "{{ description }}{{ self.render_attributes() }}{% if !self.is_unnamed() %}{{ self.render_visibility_modifier() }}{{ name }}: {{ type_ }}{% else %}{{ type_ }}{% endif  %}",
        ext = "txt"
    )]
    pub(super) struct __Field {
        pub name: String,
        pub serde_name: String,
        pub description: String,
        pub type_: String,
        pub optional: bool,
        pub flattened: bool,
        pub public: bool,
    }

    impl __Field {
        fn is_unnamed(&self) -> bool {
            self.name.parse::<u64>().is_ok()
        }

        fn render_visibility_modifier(&self) -> String {
            if self.public {
                "pub ".into()
            } else {
                "".into()
            }
        }

        fn render_attributes(&self) -> String {
            let mut attrs = vec![];
            if self.serde_name != self.name {
                attrs.push(format!("rename = \"{}\"", self.serde_name));
            }
            if self.optional {
                attrs.push("default".into());

                // this one is important to not serialize undefined values
                // as this is the special built-in type which allows to differentiate between undefined and null
                if self.type_.starts_with("reflectapi::Option<") {
                    attrs.push("skip_serializing_if = \"reflectapi::Option::is_undefined\"".into());
                }
                // the rest are nice to have, we enumerate only commonly used std types
                if self.type_.starts_with("std::option::Option<") {
                    attrs.push("skip_serializing_if = \"std::option::Option::is_none\"".into());
                }
                if self.type_ == "()" {
                    attrs.push("skip_serializing".into());
                }
                if self.type_.starts_with("std::string::String") {
                    attrs.push("skip_serializing_if = \"std::string::String::is_empty\"".into());
                }
                if self.type_.starts_with("std::vec::Vec<") {
                    attrs.push("skip_serializing_if = \"std::vec::Vec::is_empty\"".into());
                }
                if self.type_.starts_with("std::collections::") {
                    let type_without_generics = self.type_.split('<').next().unwrap();
                    attrs.push(format!(
                        "skip_serializing_if = \"{}::is_empty\"",
                        type_without_generics
                    ));
                }
            }
            if self.flattened {
                attrs.push("flattened".into());
            }
            if attrs.is_empty() {
                "".into()
            } else {
                format!("#[serde({})]\n    ", attrs.join(", "))
            }
        }
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}pub type {{ name }} = {{ type_ }};",
        ext = "txt"
    )]
    pub(super) struct __Alias {
        pub name: String,
        pub description: String,
        pub type_: String,
    }

    #[derive(Template)]
    #[template(
        source = "
{{ description }}pub struct {{ name }};",
        ext = "txt"
    )]
    pub(super) struct __Unit {
        pub name: String,
        pub description: String,
    }

    #[derive(Template)]
    #[template(
        source = "async fn {{ name }}(&self, input: {{ input_type }}, headers: {{ input_headers }})
        -> Result<{{ output_type }}, Error<{{ error_type }}, E>> {
            __request_impl(&self.client, \"{{ path }}\", input, headers).await
}",
        ext = "txt"
    )]
    pub(super) struct __FunctionImplementationTemplate {
        pub name: String,
        pub path: String,
        pub input_type: String,
        pub input_headers: String,
        pub output_type: String,
        pub error_type: String,
    }

    pub(super) struct ClientImplementationGroup {
        pub offset: usize,
        pub functions: IndexMap<String, String>,
        pub subgroups: IndexMap<String, ClientImplementationGroup>,
    }

    impl ClientImplementationGroup {
        fn offset(&self) -> String {
            " ".repeat(self.offset)
        }
        pub fn render(&self) -> String {
            let mut result = vec![];
            result.push(format!("{{"));
            for (name, function) in self.functions.iter() {
                result.push(format!(
                    "{}{}: {}(client_instance),",
                    self.offset(),
                    name,
                    function
                ));
            }
            for (name, group) in self.subgroups.iter() {
                result.push(format!("{}{}: {}", self.offset(), name, group.render()));
            }
            result.push(format!("{}}},", " ".repeat(self.offset - 4)));
            result.join("\n")
        }
    }
}

struct __FunctionGroup {
    functions: Vec<String>,
    subgroups: IndexMap<String, __FunctionGroup>,
}

impl __FunctionGroup {
    fn render(&self, offset: u8) -> String {
        let mut result = vec![];
        result.push(format!("{{"));
        for function in self.functions.iter() {
            result.push(format!("{}{},", " ".repeat(offset as usize), function));
        }
        for (name, group) in self.subgroups.iter() {
            result.push(format!(
                "{}{}: {}",
                " ".repeat(offset as usize),
                name,
                group.render(offset + 4)
            ));
        }
        result.push(format!("{}}}", " ".repeat(offset as usize - 4)));
        result.join("\n")
    }
}

fn __function_groups_from_function_names(function_names: Vec<String>) -> __FunctionGroup {
    let mut root_group = __FunctionGroup {
        functions: vec![],
        subgroups: IndexMap::new(),
    };
    for function_name in function_names {
        let mut group = &mut root_group;
        let mut parts = function_name.split(".").collect::<Vec<_>>();
        parts.pop().unwrap();
        for part in parts {
            group = group
                .subgroups
                .entry(part.into())
                .or_insert(__FunctionGroup {
                    functions: vec![],
                    subgroups: IndexMap::new(),
                });
        }
        group.functions.push(function_name);
    }
    root_group
}

fn client_impl_from_function_group(
    offset: usize,
    group: &__FunctionGroup,
) -> templates::ClientImplementationGroup {
    templates::ClientImplementationGroup {
        offset: offset,
        functions: group
            .functions
            .iter()
            .map(|f| {
                (
                    f.split('.').last().unwrap().replace("-", "_"),
                    f.replace('.', "__").replace("-", "_"),
                )
            })
            .collect(),
        subgroups: group
            .subgroups
            .iter()
            .map(|(n, g)| (n.clone(), client_impl_from_function_group(offset + 4, g)))
            .collect(),
    }
}

fn __function_signature(
    function: &Function,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> (String, String, String, String) {
    let input_type = if let Some(input_type) = function.input_type.as_ref() {
        __type_ref_to_ts_ref(input_type, schema, implemented_types)
    } else {
        "()".into()
    };
    let input_headers = if let Some(input_headers) = function.input_headers.as_ref() {
        __type_ref_to_ts_ref(input_headers, schema, implemented_types)
    } else {
        "()".into()
    };
    let output_type = if let Some(output_type) = function.output_type.as_ref() {
        __type_ref_to_ts_ref(output_type, schema, implemented_types)
    } else {
        "()".into()
    };
    let error_type = if let Some(error_type) = function.error_type.as_ref() {
        __type_ref_to_ts_ref(error_type, schema, implemented_types)
    } else {
        "()".into()
    };
    (input_type, input_headers, output_type, error_type)
}

fn modules_from_function_group(
    name: String,
    group: &__FunctionGroup,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
    functions_by_name: &IndexMap<String, &Function>,
) -> templates::__Module {
    let mut module = templates::__Module {
        name: name,
        types: vec![],
        submodules: IndexMap::new(),
    };
    let mut type_template = templates::__Struct {
        name: "Interface<E, C: crate::generated::Client<E>>".into(),
        description: "".into(),
        fields: Default::default(),
        is_tuple: false,
    };

    for subgroup_name in group.subgroups.keys() {
        type_template.fields.push(templates::__Field {
            name: subgroup_name.clone(),
            serde_name: subgroup_name.clone(),
            description: "".into(),
            type_: format!(
                "crate::generated::__definition::{}::Interface<E, C>",
                subgroup_name.to_string().replace("-", "_")
            ),
            optional: false,
            flattened: false,
            public: true,
        });
    }
    for field in vec![
        ("client", "C"),
        ("base_url", "std::string::String"),
        ("marker", "std::marker::PhantomData<E>"),
    ] {
        type_template.fields.push(templates::__Field {
            name: field.0.into(),
            serde_name: field.0.into(),
            description: "".into(),
            type_: field.1.into(),
            optional: false,
            flattened: false,
            public: false,
        });
    }
    module.types.push(type_template.render().unwrap());

    for function_name in group.functions.iter() {
        let function = functions_by_name.get(function_name).unwrap();
        let (input_type, input_headers, output_type, error_type) =
            __function_signature(function, schema, implemented_types);
        // type_template.fields.push(templates::__Field {
        //     name: function_name.split('.').last().unwrap().replace("-", "_"),
        //     serde_name: String::new(),
        //     description: __doc_to_ts_comments(function.description.as_str(), 4),
        //     type_: format!(
        //         "(input: {}, headers: {})\n        => Result<{}, {}>",
        //         input_type, input_headers, output_type, error_type
        //     ),
        //     optional: false,
        //     flattened: false,
        // });
    }

    for (subgroup_name, subgroup) in group.subgroups.iter() {
        module.submodules.insert(
            subgroup_name.clone(),
            modules_from_function_group(
                subgroup_name.clone(),
                subgroup,
                schema,
                implemented_types,
                functions_by_name,
            ),
        );
    }
    module
}

fn __modules_from_rendered_types(
    original_type_names: Vec<String>,
    mut rendered_types: HashMap<String, String>,
) -> templates::__Module {
    let mut root_module = templates::__Module {
        name: "".into(),
        types: vec![],
        submodules: IndexMap::new(),
    };

    for original_type_name in original_type_names {
        let mut module = &mut root_module;
        let mut parts = original_type_name.split("::").collect::<Vec<_>>();
        parts.pop().unwrap();
        for part in parts {
            module = module
                .submodules
                .entry(part.into())
                .or_insert(templates::__Module {
                    name: part.into(),
                    types: vec![],
                    submodules: IndexMap::new(),
                });
        }
        if let Some(rendered_type) = rendered_types.remove(&original_type_name) {
            module.types.push(rendered_type);
        }
    }

    root_module
}

fn __render_function(
    function: &Function,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Result<String, anyhow::Error> {
    let (input_type, input_headers, output_type, error_type) =
        __function_signature(function, schema, implemented_types);
    let function_template = templates::__FunctionImplementationTemplate {
        name: function.name.replace("-", "_").replace('.', "__"),
        path: format!("{}/{}", function.path, function.name),
        input_type,
        input_headers,
        output_type,
        error_type,
    };
    function_template
        .render()
        .context("Failed to render template")
}

fn __render_type(
    type_def: &crate::Type,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Result<String, anyhow::Error> {
    let type_name = __type_to_ts_name(&type_def);

    Ok(match type_def {
        crate::Type::Struct(struct_def) => {
            if struct_def.is_unit() {
                let unit_struct_template = templates::__Unit {
                    name: type_name,
                    description: __doc_to_ts_comments(&struct_def.description, 0),
                };
                unit_struct_template
                    .render()
                    .context("Failed to render template")?
            } else if struct_def.is_alias() {
                let field_type_ref = struct_def.fields.first().unwrap().type_ref.clone();
                let alias_template = templates::__Alias {
                    name: type_name,
                    description: __doc_to_ts_comments(&struct_def.description, 0),
                    type_: __type_ref_to_ts_ref(&field_type_ref, schema, implemented_types),
                };
                alias_template
                    .render()
                    .context("Failed to render template")?
            } else {
                let interface_template = templates::__Struct {
                    name: type_name,
                    description: __doc_to_ts_comments(&struct_def.description, 0),
                    is_tuple: struct_def.is_tuple(),
                    fields: struct_def
                        .fields
                        .iter()
                        .map(|field| templates::__Field {
                            name: field.name().into(),
                            serde_name: field.serde_name().into(),
                            description: __doc_to_ts_comments(&field.description, 4),
                            type_: __type_ref_to_ts_ref(&field.type_ref, schema, implemented_types),
                            optional: !field.required,
                            flattened: field.flattened,
                            public: true,
                        })
                        .collect::<Vec<_>>(),
                };
                interface_template
                    .render()
                    .context("Failed to render template")?
            }
        }
        crate::Type::Enum(enum_def) => {
            let enum_template = templates::__Enum {
                name: type_name,
                description: __doc_to_ts_comments(&enum_def.description, 0),
                representation: enum_def.representation.clone(),
                variants: enum_def
                    .variants
                    .iter()
                    .map(|variant| templates::__Variant {
                        name: variant.name().into(),
                        serde_name: variant.serde_name().into(),
                        description: __doc_to_ts_comments(&variant.description, 4),
                        fields: variant
                            .fields
                            .iter()
                            .map(|field| templates::__Field {
                                name: field.name().into(),
                                serde_name: field.serde_name().into(),
                                description: __doc_to_ts_comments(&field.description, 12),
                                type_: __type_ref_to_ts_ref(
                                    &field.type_ref,
                                    schema,
                                    implemented_types,
                                ),
                                optional: !field.required,
                                flattened: field.flattened,
                                public: false,
                            })
                            .collect::<Vec<_>>(),
                        discriminant: variant.discriminant,
                        untagged: variant.untagged,
                    })
                    .collect::<Vec<_>>(),
            };
            enum_template
                .render()
                .context("Failed to render template")?
        }
        crate::Type::Primitive(_) => {
            // do nothing, we will use the primitive types as is
            "".into()
        }
    })
}

fn __type_ref_to_ts_ref(
    type_ref: &crate::TypeReference,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> String {
    if let Some(resolved_type) = __resolve_type_ref(type_ref, schema, implemented_types) {
        return resolved_type;
    }

    let mut prefix = schema
        .get_type(type_ref.name())
        .filter(|i| !i.is_primitive())
        .map(|i| "crate::generated::".to_string())
        .unwrap_or_default();

    if type_ref.name().starts_with("reflectapi::") {
        prefix = "".into();
    }

    format!(
        "{}{}{}",
        prefix,
        type_ref.name,
        __type_ref_params_to_ts_ref(&type_ref.parameters, schema, implemented_types)
    )
}

fn __type_ref_params_to_ts_ref(
    type_params: &Vec<crate::TypeReference>,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> String {
    let p = type_params
        .iter()
        .map(|type_ref| __type_ref_to_ts_ref(type_ref, schema, implemented_types))
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn __type_to_ts_name(type_def: &crate::Type) -> String {
    let n = type_def
        .name()
        .split("::")
        .last()
        .unwrap_or_default()
        .to_string();
    let p = __type_params_to_ts_name(type_def.parameters());
    format!("{}{}", n, p)
}

fn __type_params_to_ts_name(type_params: std::slice::Iter<'_, crate::TypeParameter>) -> String {
    let p = type_params
        .map(|type_param| type_param.name.clone())
        .collect::<Vec<_>>()
        .join(", ");
    if p.is_empty() {
        p
    } else {
        format!("<{}>", p)
    }
}

fn __resolve_type_ref(
    type_ref: &crate::TypeReference,
    schema: &crate::Schema,
    implemented_types: &HashMap<String, String>,
) -> Option<String> {
    let Some(mut implementation) = implemented_types.get(type_ref.name.as_str()).cloned() else {
        return None;
    };

    let Some(type_def) = schema.get_type(type_ref.name()) else {
        return None;
    };

    for (type_def_param, type_ref_param) in type_def.parameters().zip(type_ref.parameters.iter()) {
        if implementation.contains(type_def_param.name.as_str()) {
            implementation = implementation.replace(
                type_def_param.name.as_str(),
                __type_ref_to_ts_ref(type_ref_param, schema, implemented_types).as_str(),
            );
        }
    }

    Some(implementation)
}

fn __doc_to_ts_comments(doc: &str, offset: u8) -> String {
    if doc.is_empty() {
        return "".into();
    }

    let offset = " ".repeat(offset as usize);
    let doc = doc.split("\n").collect::<Vec<_>>();
    let sp = if doc.iter().all(|i| i.starts_with(" ")) {
        ""
    } else {
        " "
    };
    let doc = doc
        .iter()
        .map(|line| format!("///{}{}", sp, line.trim_end()))
        .collect::<Vec<_>>()
        .join(format!("\n{}", offset).as_str());
    format!("{}\n{}", doc, offset)
}

fn __build_implemented_types() -> HashMap<String, String> {
    let mut implemented_types = HashMap::new();

    // TODO once the todos below are addressed it would be possible to drop this function completely

    // warning: all generic type parameter names should match reflect defnition coming from
    // the implementation of reflect for standard types

    // TODO this one should probably be defined as primitive type
    implemented_types.insert(
        "std::option::Option".into(),
        "std::option::Option<T>".into(),
    );
    // TODO this one should probably be defined as primitive type
    implemented_types.insert("reflectapi::Option".into(), "reflectapi::Option<T>".into());

    // TODO the following could be declared via type aliases in the generated code or in the reflect api
    implemented_types.insert("std::tuple::Tuple1".into(), "(T1)".into());
    implemented_types.insert("std::tuple::Tuple2".into(), "(T1, T2)".into());
    implemented_types.insert("std::tuple::Tuple3".into(), "(T1, T2, T3)".into());
    implemented_types.insert("std::tuple::Tuple4".into(), "(T1, T2, T3, T4)".into());
    implemented_types.insert("std::tuple::Tuple5".into(), "(T1, T2, T3, T4, T5)".into());
    implemented_types.insert(
        "std::tuple::Tuple6".into(),
        "(T1, T2, T3, T4, T5, T6)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple7".into(),
        "(T1, T2, T3, T4, T5, T6, T7)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple8".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple9".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple10".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple11".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)".into(),
    );
    implemented_types.insert(
        "std::tuple::Tuple12".into(),
        "(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)".into(),
    );

    implemented_types
}
